{"version":3,"file":"ej2-compression.umd.min.js","sources":["../src/utils.js","../src/zip-archive.js","../src/compression-writer.js","../src/decompressor-huffman-tree.js","../src/checksum-calculator.js","../src/compression-reader.js"],"sourcesContent":["/* eslint-disable */\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    Utils.bitReverse = function (value) {\n        return (Utils.reverseBits[value & 15] << 12\n            | Utils.reverseBits[(value >> 4) & 15] << 8\n            | Utils.reverseBits[(value >> 8) & 15] << 4\n            | Utils.reverseBits[value >> 12]);\n    };\n    Utils.bitConverterToInt32 = function (value, index) {\n        return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;\n    };\n    Utils.bitConverterToInt16 = function (value, index) {\n        return value[index] | value[index + 1] << 8;\n    };\n    Utils.bitConverterToUInt32 = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterToUInt16 = function (value, index) {\n        var uint = new Uint16Array(1);\n        uint[0] = (value[index] | value[index + 1] << 8);\n        return uint[0];\n    };\n    Utils.bitConverterUintToInt32 = function (value) {\n        var uint = new Int32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToUint = function (value) {\n        var uint = new Uint32Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.bitConverterInt32ToInt16 = function (value) {\n        var uint = new Int16Array(1);\n        uint[0] = value;\n        return uint[0];\n    };\n    Utils.byteToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.byteIntToString = function (value) {\n        var str = '';\n        for (var i = 0; i < value.length; i++) {\n            str += String.fromCharCode(value[i]);\n        }\n        return str;\n    };\n    Utils.arrayCopy = function (source, sourceIndex, destination, destinationIndex, dataToCopy) {\n        var temp = new Uint8Array(source.buffer, sourceIndex);\n        var data = temp.subarray(0, dataToCopy);\n        destination.set(data, destinationIndex);\n    };\n    Utils.mergeArray = function (arrayOne, arrayTwo) {\n        var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n        mergedArray.set(arrayOne);\n        mergedArray.set(arrayTwo, arrayOne.length);\n        return mergedArray;\n    };\n    /**\n     * @private\n     */\n    Utils.encodedString = function (input) {\n        var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var chr1;\n        var chr2;\n        var chr3;\n        var encode1;\n        var encode2;\n        var encode3;\n        var encode4;\n        var count = 0;\n        var resultIndex = 0;\n        /*let dataUrlPrefix: string = 'data:';*/\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n        var totalLength = input.length * 3 / 4;\n        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {\n            totalLength--;\n        }\n        if (totalLength % 1 !== 0) {\n            // totalLength is not an integer, the length does not match a valid\n            // base64 content. That can happen if:\n            // - the input is not a base64 content\n            // - the input is *almost* a base64 content, with a extra chars at the\n            // beginning or at the end\n            // - the input uses a base64 variant (base64url for example)\n            throw new Error('Invalid base64 input, bad content length.');\n        }\n        var output = new Uint8Array(totalLength | 0);\n        while (count < input.length) {\n            encode1 = keyStr.indexOf(input.charAt(count++));\n            encode2 = keyStr.indexOf(input.charAt(count++));\n            encode3 = keyStr.indexOf(input.charAt(count++));\n            encode4 = keyStr.indexOf(input.charAt(count++));\n            chr1 = (encode1 << 2) | (encode2 >> 4);\n            chr2 = ((encode2 & 15) << 4) | (encode3 >> 2);\n            chr3 = ((encode3 & 3) << 6) | encode4;\n            output[resultIndex++] = chr1;\n            if (encode3 !== 64) {\n                output[resultIndex++] = chr2;\n            }\n            if (encode4 !== 64) {\n                output[resultIndex++] = chr3;\n            }\n        }\n        return output;\n    };\n    Utils.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    Utils.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return Utils;\n}());\nexport { Utils };\n/* eslint-enable */ \n","/* eslint-disable */\nimport { CompressedStreamWriter, Stream, CompressedStreamReader } from './index';\nimport { Save } from '@syncfusion/ej2-file-utils';\nimport { Utils } from './utils';\nvar CRC32TABLE = [];\n/// <summary>\n/// Size of the int value in bytes.\n/// </summary>\nvar INT_SIZE = 4;\n/// <summary>\n/// Size of the short value in bytes.\n/// </summary>\nvar SHORT_SIZE = 2;\n/// <summary>\n/// End of central directory signature.\n/// </summary>\nvar CentralDirectoryEndSignature = 0x06054b50;\n/// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\nvar CentralDirSizeOffset = 12;\n/// <summary>\n/// Central header signature.\n/// </summary>\nvar CentralHeaderSignature = 0x02014b50;\n/// <summary>\n/// Buffer size.\n/// </summary>\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nvar ZipArchive = /** @class */ (function () {\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    function ZipArchive() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    Object.defineProperty(ZipArchive.prototype, \"items\", {\n        get: function () {\n            return this.files;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n        /**\n         * gets compression level\n         */\n        get: function () {\n            return this.level;\n        },\n        /**\n         * sets compression level\n         */\n        set: function (level) {\n            this.level = level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchive.prototype, \"length\", {\n        /**\n         * gets items count\n         */\n        get: function () {\n            if (this.files === undefined) {\n                return 0;\n            }\n            return this.files.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    ZipArchive.prototype.addItem = function (item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (var i = 0; i < this.files.length; i++) {\n            var file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    };\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    ZipArchive.prototype.addDirectory = function (directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    };\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    ZipArchive.prototype.getItem = function (index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    };\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    ZipArchive.prototype.contains = function (item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    };\n    ZipArchive.prototype.open = function (base64String) {\n        //return promise = new Promise((resolve: Function, reject: Function) => {\n        var zipArchive = this;\n        var zipByteArray = Utils.encodedString(base64String);\n        if (zipByteArray.length == 0)\n            throw new DOMException(\"stream\");\n        var stream = new Stream(zipByteArray);\n        //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n        var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n        if (lCentralDirEndPosition < 0)\n            throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\");\n        // Step2. Locate central directory and iterate through all items\n        stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n        var iCentralDirSize = ZipArchive.ReadInt32(stream);\n        var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;\n        // verify that this is really central directory\n        stream.position = lCentralDirPosition;\n        this.readCentralDirectoryDataAndExtractItems(stream);\n        //});\n        // let zipArchive: ZipArchive = this;\n        //let promise: Promise<ZipArchive>;\n        // return promise = new Promise((resolve: Function, reject: Function) => {\n        //     let reader: FileReader = new FileReader();\n        //     reader.onload = (e: Event) => {\n        //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n        //         let zipReader: ZipReader = new ZipReader(data);\n        //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n        //             for (let i: number = 0; i < entries.length; i++) {\n        //                 let entry: ZipEntry = entries[i];\n        //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n        //                 item.data = entry.data;\n        //                 item.compressionMethod = entry.compressionMethod;\n        //                 item.crc = entry.crc;\n        //                 item.lastModified = entry.lastModified;\n        //                 item.lastModifiedDate = entry.lastModifiedDate;\n        //                 item.size = entry.size;\n        //                 item.uncompressedSize = entry.uncompressedSize;\n        //                 zipArchive.addItem(item);\n        //             }\n        //             resolve(zipArchive);\n        //         });\n        //     };\n        //     reader.readAsArrayBuffer(fileName);\n        // });\n    };\n    /// <summary>\n    /// Read central directory record from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read from.</param>\n    ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        var itemHelper;\n        while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n            itemHelper = new ZipArchiveItemHelper();\n            itemHelper.readCentralDirectoryData(stream);\n            itemHelper;\n            // let item: ZipArchiveItem = new ZipArchiveItem(this);\n            // item.ReadCentralDirectoryData(stream);\n            // m_arrItems.Add(item);\n        }\n        itemHelper.readData(stream, itemHelper.checkCrc);\n        itemHelper.decompressData();\n        this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n    };\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    ZipArchive.prototype.save = function (fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal(fileName, false).then(function () {\n                resolve(zipArchive);\n            });\n        });\n    };\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    ZipArchive.prototype.saveAsBlob = function () {\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            zipArchive.saveInternal('', true).then(function (blob) {\n                resolve(blob);\n            });\n        });\n    };\n    ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n        var _this = this;\n        var zipArchive = this;\n        var promise;\n        return promise = new Promise(function (resolve, reject) {\n            var zipData = [];\n            var dirLength = 0;\n            for (var i = 0; i < zipArchive.files.length; i++) {\n                var compressedObject = _this.getCompressedData(_this.files[i]);\n                compressedObject.then(function (data) {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchive.prototype.destroy = function () {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (var i = 0; i < this.files.length; i++) {\n                var file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    };\n    ZipArchive.prototype.getCompressedData = function (item) {\n        var zipArchive = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (item instanceof ZipArchiveItem) {\n                var reader_1 = new FileReader();\n                reader_1.onload = function () {\n                    var input = new Uint8Array(reader_1.result);\n                    var data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        var length_1 = 0;\n                        for (var i = 0; i < data.compressedData.length; i++) {\n                            length_1 += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length_1;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader_1.readAsArrayBuffer(item.data);\n            }\n            else {\n                var data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    };\n    ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n        var compressor = new CompressedStreamWriter(true);\n        var currentIndex = 0;\n        var nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            var subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    };\n    ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n        var extFileAttr = 0;\n        var date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        var header = this.writeHeader(data, date);\n        var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    };\n    ZipArchive.prototype.writeHeader = function (data, date) {\n        var zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    };\n    ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n        var cenDirLen = 0;\n        var buffer = [];\n        for (var i = 0; i < zipData.length; i++) {\n            var item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (var i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        var blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    };\n    ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n        var directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    };\n    ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n        var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    };\n    ZipArchive.prototype.getArrayBuffer = function (input) {\n        var a = new Uint8Array(input.length);\n        for (var j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    };\n    ZipArchive.prototype.getBytes = function (value, offset) {\n        var bytes = '';\n        for (var i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    };\n    ZipArchive.prototype.getModifiedTime = function (date) {\n        var modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    };\n    ZipArchive.prototype.getModifiedDate = function (date) {\n        var modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    };\n    ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (var i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    };\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    ZipArchive.initCrc32Table = function () {\n        var i;\n        for (var j = 0; j < 256; j++) {\n            i = j;\n            for (var k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    };\n    ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n        if (stream == null)\n            throw new DOMException(\"stream\");\n        //   if( !stream.CanSeek || !stream.CanRead )\n        //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n        // read last 4 bytes and compare with required value\n        var lStreamSize = stream.inputStream.buffer.byteLength;\n        if (lStreamSize < 4)\n            return -1;\n        var arrBuffer = new Uint8Array(4);\n        var lLastPos = Math.max(0, lStreamSize - maxCount);\n        var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n        stream.position = lCurrentPosition;\n        stream.read(arrBuffer, 0, INT_SIZE);\n        var uiCurValue = arrBuffer[0];\n        var bFound = (uiCurValue == value);\n        if (!bFound) {\n            while (lCurrentPosition > lLastPos) {\n                // remove unnecessary byte and replace it with new value.\n                uiCurValue <<= 8;\n                lCurrentPosition--;\n                stream.position = lCurrentPosition;\n                uiCurValue += stream.readByte();\n                if (uiCurValue == value) {\n                    bFound = true;\n                    break;\n                }\n            }\n        }\n        return bFound ? lCurrentPosition : -1;\n    };\n    /// <summary>\n    /// Extracts Int32 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt32 = function (stream) {\n        var buffer = new Uint8Array(INT_SIZE);\n        if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt32(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadInt16 = function (stream) {\n        var buffer = new Uint8Array(SHORT_SIZE);\n        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n            throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n        }\n        return Utils.bitConverterToInt16(buffer, 0);\n    };\n    /// <summary>\n    /// Extracts unsigned Int16 value from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <returns>Extracted value.</returns>\n    ZipArchive.ReadUInt16 = function (stream) {\n        {\n            var buffer = new Uint8Array(SHORT_SIZE);\n            if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n                throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n            }\n            return Utils.bitConverterToInt16(buffer, 0);\n        }\n    };\n    return ZipArchive;\n}());\nexport { ZipArchive };\nvar ZipArchiveItemHelper = /** @class */ (function () {\n    function ZipArchiveItemHelper() {\n        /// <summary>\n        /// Zip header signature.\n        /// </summary>\n        this.headerSignature = 0x04034b50;\n        /// <summary>\n        /// Indicates whether we should check Crc value when reading item's data. Check\n        /// is performed when user gets access to decompressed data for the first time.\n        /// </summary>\n        this.checkCrc = true;\n        /// <summary>\n        /// Crc.\n        /// </summary>\n        this.crc32 = 0;\n    }\n    /// <summary>\n    /// Read data from the stream based on the central directory.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n    ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n        // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n        stream.position += 4;\n        this.options = ZipArchive.ReadInt16(stream);\n        this.compressionMethod = ZipArchive.ReadInt16(stream);\n        this.checkCrc = (this.compressionMethod != 99); //COmpression.Defalte != SecurityConstants.AES\n        //m_bCompressed = true;\n        // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n        var lastModified = ZipArchive.ReadInt32(stream);\n        //LastModified = ConvertToDateTime(lastModified);\n        this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n        this.compressedSize = ZipArchive.ReadInt32(stream);\n        this.originalSize = ZipArchive.ReadInt32(stream);\n        var iFileNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n        var iCommentLength = ZipArchive.ReadInt16(stream);\n        // on the current moment we ignore and \"disk number start\" (2 bytes),\n        // \"internal file attributes\" (2 bytes).\n        stream.position += 4;\n        this.externalAttributes = ZipArchive.ReadInt32(stream);\n        this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n        var arrBuffer = new Uint8Array(iFileNameLength);\n        stream.read(arrBuffer, 0, iFileNameLength);\n        var m_strItemName = Utils.byteToString(arrBuffer);\n        m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n        this.name = m_strItemName;\n        stream.position += iExtraFieldLenth + iCommentLength;\n        if (this.options != 0)\n            this.options = 0;\n    };\n    /// <summary>\n    /// Reads zipped data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n    ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        stream.position = this.localHeaderOffset;\n        this.checkCrc = checkCrc;\n        this.readLocalHeader(stream);\n        this.readCompressedData(stream);\n    };\n    ZipArchiveItemHelper.prototype.decompressData = function () {\n        if (this.compressionMethod == 8) {\n            if (this.originalSize > 0) {\n                this.decompressDataOld();\n            }\n        }\n    };\n    ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n        var reader = new CompressedStreamReader(this.compressedStream, true);\n        var decompressedData;\n        if (this.originalSize > 0)\n            decompressedData = new Stream(new Uint8Array(this.originalSize));\n        var arrBuffer = new Uint8Array(BufferSize);\n        var iReadBytes;\n        var past = new Uint8Array(0);\n        while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n            //             past = new Uint8Array(decompressedData.length);\n            // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n            decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n        }\n        this.unCompressedStream = decompressedData.toByteArray();\n        //   this.originalSize = decompressedData.Length;\n        //   m_bControlStream = true;\n        //   m_streamData = decompressedData;\n        //   decompressedData.SetLength( m_lOriginalSize );\n        //   decompressedData.Capacity = ( int )m_lOriginalSize;\n        if (this.checkCrc) {\n            //TODO: fix this\n            //CheckCrc(decompressedData.ToArray());\n        }\n        //m_streamData.Position = 0;\n    };\n    /// <summary>\n    /// Extracts local header from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n        if (stream.length == 0)\n            throw new DOMException(\"stream\");\n        if (ZipArchive.ReadInt32(stream) != this.headerSignature)\n            throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\");\n        // TODO: it is good to verify data read from the central directory record,\n        // but on the current moment we simply skip it.\n        stream.position += 22;\n        var iNameLength = ZipArchive.ReadInt16(stream);\n        var iExtraLength = ZipArchive.ReadUInt16(stream);\n        if (this.compressionMethod == 99) //SecurityConstants.AES\n         {\n            // stream.Position += iNameLength + 8;\n            // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n            // m_actualCompression = new byte[2];\n            // stream.Read(m_actualCompression, 0, 2);\n        }\n        else if (iExtraLength > 2) {\n            stream.position += iNameLength;\n            var headerVal = ZipArchive.ReadInt16(stream);\n            if (headerVal == 0x0017) //PKZipEncryptionHeader\n                throw new DOMException(\"UnSupported\");\n            else\n                stream.position += iExtraLength - 2;\n        }\n        else\n            stream.position += iNameLength + iExtraLength;\n    };\n    /// <summary>\n    /// Extracts compressed data from the stream.\n    /// </summary>\n    /// <param name=\"stream\">Stream to read data from.</param>\n    ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n        var dataStream;\n        if (this.compressedSize > 0) {\n            var iBytesLeft = this.compressedSize;\n            dataStream = new Stream(new Uint8Array(iBytesLeft));\n            var arrBuffer = new Uint8Array(BufferSize);\n            while (iBytesLeft > 0) {\n                var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n                if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)\n                    throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n                dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n                iBytesLeft -= iBytesToRead;\n            }\n            // if(m_archive.Password != null)\n            // {\n            //     byte[] dataBuffer = new byte[dataStream.Length];\n            //     dataBuffer = dataStream.ToArray();\n            //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n            // }\n            this.compressedStream = new Uint8Array(dataStream.inputStream);\n            // m_bControlStream = true;\n        }\n        else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n         {\n            //   MemoryStream dataStream = new MemoryStream();\n            //   int bt = 0;\n            //   bool proceed=true;\n            //   while (proceed)\n            //   {\n            //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n            //       {\n            //           stream.Position -= 1;\n            //           int headerSignature = ZipArchive.ReadInt32(stream);\n            //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n            //           {\n            //               proceed = false;\n            //           }\n            //           stream.Position -= 3;\n            //       }\n            //       if (proceed)\n            //           dataStream.WriteByte((byte)bt);\n            //   }\n            //   m_streamData = dataStream;\n            //   m_lCompressedSize = m_streamData.Length;\n            //   m_bControlStream = true;\n        }\n        else if (this.compressedSize == 0) {\n            //  m_streamData = new MemoryStream();\n        }\n    };\n    return ZipArchiveItemHelper;\n}());\nexport { ZipArchiveItemHelper };\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nvar ZipArchiveItem = /** @class */ (function () {\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    function ZipArchiveItem(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n        get: function () {\n            return this.decompressedStream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n        /**\n         * Get the name of archive item\n         * @returns string\n         */\n        get: function () {\n            return this.fileName;\n        },\n        /**\n         * Set the name of archive item\n         * @param  {string} value\n         */\n        set: function (value) {\n            this.fileName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    ZipArchiveItem.prototype.destroy = function () {\n        this.fileName = undefined;\n        this.data = undefined;\n    };\n    return ZipArchiveItem;\n}());\nexport { ZipArchiveItem };\n/* eslint-enable */ \n","/* eslint-disable */\nimport { Encoding } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nvar CompressedStreamWriter = /** @class */ (function () {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    function CompressedStreamWriter(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n        /**\n         * get compressed data\n         */\n        get: function () {\n            return this.stream;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n        get: function () {\n            var compressedString = '';\n            if (this.stream !== undefined) {\n                for (var i = 0; i < this.stream.length; i++) {\n                    compressedString += String.fromCharCode.apply(null, this.stream[i]);\n                }\n            }\n            return compressedString;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.write = function (data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        var end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            var encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    };\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    CompressedStreamWriter.prototype.writeZLibHeader = function () {\n        /* Initialize header.*/\n        var headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    };\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    };\n    CompressedStreamWriter.prototype.compressData = function (finish) {\n        var success;\n        do {\n            this.fillWindow();\n            var canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    };\n    CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            var prevMatch = this.matchStart;\n            var prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    };\n    CompressedStreamWriter.prototype.discardMatch = function () {\n        var hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    };\n    CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    };\n    CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    };\n    CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    };\n    CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n        var len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        var lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    };\n    CompressedStreamWriter.prototype.fillWindow = function () {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    };\n    CompressedStreamWriter.prototype.slideWindow = function () {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (var i = 0; i < this.hashSize; ++i) {\n            var m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (var i = 0; i < this.windowSize; i++) {\n            var m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    };\n    CompressedStreamWriter.prototype.insertString = function () {\n        var match;\n        var hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    };\n    CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n        var chainLen = 4096;\n        var niceLen = 258;\n        var scan = this.stringStart;\n        var match;\n        var bestEnd = this.stringStart + this.matchLength;\n        var bestLength = Math.max(this.matchLength, 3 - 1);\n        var limit = Math.max(this.stringStart - this.maxDist, 0);\n        var stringEnd = this.stringStart + 258 - 1;\n        var scanEnd1 = this.dataWindow[bestEnd - 1];\n        var scanEnd = this.dataWindow[bestEnd];\n        var data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    };\n    CompressedStreamWriter.prototype.updateHash = function () {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    };\n    CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        var lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        var dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    };\n    CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        var blTreeCodes = 4;\n        for (var i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        var static_len = this.extraBits;\n        for (var i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (var i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    };\n    CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    };\n    CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n        if (len === 255) {\n            return 285;\n        }\n        var code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    };\n    CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n        var code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    };\n    CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (var rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    };\n    CompressedStreamWriter.prototype.huffmanReset = function () {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    };\n    CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n        for (var i = 0; i < this.bufferPosition; i++) {\n            var literalLen = this.arrLiterals[i] & 255;\n            var dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                var lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                var bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                var dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    };\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n        var uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            var array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    };\n    CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n        var result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n        var array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    };\n    CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    };\n    CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    };\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    CompressedStreamWriter.initHuffmanTree = function () {\n        var i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    };\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.close = function () {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    };\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    CompressedStreamWriter.prototype.destroy = function () {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    };\n    CompressedStreamWriter.isHuffmanTreeInitiated = false;\n    return CompressedStreamWriter;\n}());\nexport { CompressedStreamWriter };\n/**\n * represent the Huffman Tree\n */\nvar CompressorHuffmanTree = /** @class */ (function () {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n        get: function () {\n            return this.codeCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n        get: function () {\n            return this.codeLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n        get: function () {\n            return this.codeFrequency;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n        var temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        var lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    };\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.reset = function () {\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    };\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    };\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildCodes = function () {\n        var nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        var code = 0;\n        for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (var i = 0; i < this.codeCount; i++) {\n            var bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    };\n    CompressorHuffmanTree.bitReverse = function (value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    };\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    CompressorHuffmanTree.prototype.getEncodedLength = function () {\n        var len = 0;\n        for (var i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    };\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n        var maxCount;\n        var minCount;\n        var count;\n        var curLen = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    };\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n        var maxRepeatCount;\n        var minRepeatCount;\n        var currentRepeatCount;\n        var currentCodeLength = -1;\n        var i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            var nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    };\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    CompressorHuffmanTree.prototype.buildTree = function () {\n        var codesCount = this.codeFrequency.length;\n        var arrTree = new Int32Array(codesCount);\n        var treeLength = 0;\n        var maxCount = 0;\n        for (var n = 0; n < codesCount; n++) {\n            var freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                var pos = treeLength++;\n                var pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        var leafsCount = treeLength;\n        var nodesCount = leafsCount;\n        var child = new Int32Array(4 * treeLength - 2);\n        var values = new Int32Array(2 * treeLength - 1);\n        for (var i = 0; i < treeLength; i++) {\n            var node = arrTree[i];\n            var iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    };\n    CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n        do {\n            var first = arrTree[0];\n            var last = arrTree[--treeLength];\n            var lastVal = values[last];\n            var pPos = 0;\n            var path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            var second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    };\n    CompressorHuffmanTree.prototype.buildLength = function (child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        var numNodes = Math.floor(child.length / 2);\n        var numLeafs = Math.floor((numNodes + 1) / 2);\n        var overflow = 0;\n        for (var i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        var iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    };\n    CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        var nodePtr = 2 * numLeafs;\n        for (var bits = this.maxLength; bits !== 0; bits--) {\n            var n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                var childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    };\n    CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n        var lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (var i = numNodes - 1; i >= 0; i--) {\n            var childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                var bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                var bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    };\n    CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n    CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    return CompressorHuffmanTree;\n}());\nexport { CompressorHuffmanTree };\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n        var uint = new Uint32Array(1);\n        uint[0] = checksum;\n        var checksum_uint = uint[0];\n        var s1 = uint[0] = checksum_uint & 65535;\n        var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    };\n    ChecksumCalculator.checkSumBitOffset = 16;\n    ChecksumCalculator.checksumBase = 65521;\n    ChecksumCalculator.checksumIterationCount = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/* eslint-enable */ \n","/* eslint-disable */\nimport { Utils } from './index';\nvar DecompressorHuffmanTree = /** @class */ (function () {\n    function DecompressorHuffmanTree(lengths) {\n        this.buildTree(lengths);\n    }\n    DecompressorHuffmanTree.init = function () {\n        var lengths;\n        var index;\n        // Generate huffman tree for lengths.\n        lengths = new Uint8Array(288);\n        index = 0;\n        while (index < 144) {\n            lengths[index++] = 8;\n        }\n        while (index < 256) {\n            lengths[index++] = 9;\n        }\n        while (index < 280) {\n            lengths[index++] = 7;\n        }\n        while (index < 288) {\n            lengths[index++] = 8;\n        }\n        DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths);\n        // Generate huffman tree for distances.\n        lengths = new Uint8Array(32);\n        index = 0;\n        while (index < 32) {\n            lengths[index++] = 5;\n        }\n        DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n    };\n    /// <summary>\n    /// Prepares data for generating huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated tree size.</param>\n    /// <returns>Code.</returns>\n    DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n        var code = 0;\n        var treeSize = 512;\n        // Count number of codes for each code length.\n        for (var i = 0; i < lengths.length; i++) {\n            var length_1 = lengths[i];\n            if (length_1 > 0) {\n                blCount[length_1]++;\n            }\n        }\n        for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n            nextCode[bits] = code;\n            code += blCount[bits] << (16 - bits);\n            if (bits >= 10) {\n                var start = nextCode[bits] & 0x1ff80;\n                var end = code & 0x1ff80;\n                treeSize += (end - start) >> (16 - bits);\n            }\n        }\n        /*      if( code != 65536 )\n          throw new ZipException( \"Code lengths don't add up properly.\" );*/\n        return { 'code': code, 'treeSize': treeSize };\n    };\n    /// <summary>\n    /// Generates huffman tree.\n    /// </summary>\n    /// <param name=\"blCount\">Array of counts of each code length.</param>\n    /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n    /// <param name=\"code\">Precalculated code.</param>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    /// <param name=\"treeSize\">Calculated size of the tree.</param>\n    /// <returns>Generated tree.</returns>\n    DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n        var tree = new Int16Array(treeSize);\n        var pointer = 512;\n        var increment = 1 << 7;\n        for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n            var end = code & 0x1ff80;\n            code -= blCount[bits] << (16 - bits);\n            var start = code & 0x1ff80;\n            for (var i = start; i < end; i += increment) {\n                tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16((-pointer << 4) | bits);\n                pointer += 1 << (bits - 9);\n            }\n        }\n        for (var i = 0; i < lengths.length; i++) {\n            var bits = lengths[i];\n            if (bits == 0) {\n                continue;\n            }\n            code = nextCode[bits];\n            var revcode = Utils.bitReverse(code);\n            if (bits <= 9) {\n                do {\n                    tree[revcode] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < 512);\n            }\n            else {\n                var subTree = tree[revcode & 511];\n                var treeLen = 1 << (subTree & 15);\n                subTree = -(subTree >> 4);\n                do {\n                    tree[subTree | (revcode >> 9)] = Utils.bitConverterInt32ToInt16((i << 4) | bits);\n                    revcode += 1 << bits;\n                } while (revcode < treeLen);\n            }\n            nextCode[bits] = code + (1 << (16 - bits));\n        }\n        return tree;\n    };\n    /// <summary>\n    /// Builds huffman tree from array of code lengths.\n    /// </summary>\n    /// <param name=\"lengths\">Array of code lengths.</param>\n    DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n        // Count of codes for each code length.\n        var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        // Numerical value of the smallest code for each code length.\n        var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var prepareData = this.prepareData(blCount, nextCode, lengths);\n        this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n    };\n    /// <summary>\n    /// Reads and decompresses one symbol.\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <returns></returns>\n    DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n        var lookahead;\n        var symbol;\n        if ((lookahead = input.peekBits(9)) >= 0) {\n            if ((symbol = this.m_Tree[lookahead]) >= 0) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            var subtree = -(symbol >> 4);\n            var bitlen = symbol & 15;\n            if ((lookahead = input.peekBits(bitlen)) >= 0) {\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                var bits = input.availableBits;\n                lookahead = input.peekBits(bits);\n                symbol = this.m_Tree[subtree | (lookahead >> 9)];\n                if ((symbol & 15) <= bits) {\n                    input.skipBits((symbol & 15));\n                    return symbol >> 4;\n                }\n                else {\n                    return -1;\n                }\n            }\n        }\n        else {\n            var bits = input.availableBits;\n            lookahead = input.peekBits(bits);\n            symbol = this.m_Tree[lookahead];\n            if (symbol >= 0 && (symbol & 15) <= bits) {\n                input.skipBits((symbol & 15));\n                return symbol >> 4;\n            }\n            else {\n                return -1;\n            }\n        }\n    };\n    Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding lengths.\n        /// </summary>\n        get: function () {\n            return this.m_LengthTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n        /// <summary>\n        /// GET huffman tree for encoding and decoding distances.\n        /// </summary>\n        get: function () {\n            return this.m_DistanceTree;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Maximum count of bits.\n    /// </summary>\n    DecompressorHuffmanTree.MAX_BITLEN = 15;\n    return DecompressorHuffmanTree;\n}());\nexport { DecompressorHuffmanTree };\n/* eslint-enable */ \n","/* eslint-disable */\n/// <summary>\n/// Checksum calculator, based on Adler32 algorithm.\n/// </summary>\nvar ChecksumCalculator = /** @class */ (function () {\n    function ChecksumCalculator() {\n    }\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"checksum\">Current checksum.</param>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumUpdate = function (checksum, buffer, offset, length) {\n        var checkSumUInt = checksum;\n        var s1 = checkSumUInt & 65535;\n        var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;\n        while (length > 0) {\n            var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (buffer[offset++] & 255);\n                s2 = s2 + s1;\n            }\n            s1 %= this.DEF_CHECKSUM_BASE;\n            s2 %= this.DEF_CHECKSUM_BASE;\n        }\n        checkSumUInt = (s2 << this.DEF_CHECKSUM_BIT_OFFSET) | s1;\n        checksum = checkSumUInt;\n    };\n    /// <summary>\n    /// Generates checksum by calculating checksum of the\n    /// given buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    ChecksumCalculator.ChecksumGenerate = function (buffer, offset, length) {\n        var result = 1;\n        ChecksumCalculator.ChecksumUpdate(result, buffer, offset, length);\n        return result;\n    };\n    /// <summary>\n    /// Bits offset, used in adler checksum calculation.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BIT_OFFSET = 16;\n    /// <summary>\n    /// Lagrest prime, less than 65535\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_BASE = 65521;\n    /// <summary>\n    /// Count of iteration used in calculated of the adler checksumm.\n    /// </summary>\n    ChecksumCalculator.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;\n    return ChecksumCalculator;\n}());\nexport { ChecksumCalculator };\n/* eslint-enable */ \n","/* eslint-disable */\nimport { DecompressorHuffmanTree } from './decompressor-huffman-tree';\nimport { Utils } from './utils';\nimport { ChecksumCalculator } from './checksum-calculator';\nvar CompressedStreamReader = /** @class */ (function () {\n    function CompressedStreamReader(stream, bNoWrap) {\n        /// <summary>\n        /// Code lengths for the code length alphabet.\n        /// </summary>\n        this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n        /// <summary>\n        /// Mask for compression method to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_METHOD_MASK = 15 << 8;\n        /// <summary>\n        /// Mask for compression info to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_INFO_MASK = 240 << 8;\n        /// <summary>\n        /// Mask for check bits to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FCHECK = 31;\n        /// <summary>\n        /// Mask for dictionary presence to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FDICT = 32;\n        /// <summary>\n        /// Mask for compression level to be decoded from 16-bit header.\n        /// </summary>\n        this.DEF_HEADER_FLAGS_FLEVEL = 192;\n        /// <summary>\n        /// Maximum size of the data window.\n        /// </summary>\n        this.DEF_MAX_WINDOW_SIZE = 65535;\n        /// <summary>\n        /// Maximum length of the repeatable block.\n        /// </summary>\n        this.DEF_HUFFMAN_REPEATE_MAX = 258;\n        /// <summary>\n        /// End of the block sign.\n        /// </summary>\n        this.DEF_HUFFMAN_END_BLOCK = 256;\n        /// <summary>\n        /// Minimal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;\n        /// <summary>\n        /// Maximal length code.\n        /// </summary>\n        this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;\n        /// <summary>\n        /// Maximal distance code.\n        /// </summary>\n        this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;\n        /// <summary>\n        /// Currently calculated checksum,\n        /// based on Adler32 algorithm.\n        /// </summary>\n        this.mCheckSum = 1;\n        /// <summary>\n        /// Currently read 4 bytes.\n        /// </summary>\n        this.tBuffer = 0;\n        /// <summary>\n        /// Count of bits that are in buffer.\n        /// </summary>\n        this.mBufferedBits = 0;\n        /// <summary>\n        /// Temporary buffer.\n        /// </summary>\n        this.mTempBuffer = new Uint8Array(4);\n        /// <summary>\n        /// 32k buffer for unpacked data.\n        /// </summary>\n        this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);\n        /// <summary>\n        /// No wrap mode.\n        /// </summary>\n        this.mbNoWrap = false;\n        /// <summary>\n        /// Window size, can not be larger than 32k.\n        /// </summary>\n        this.mWindowSize = 0;\n        /// <summary>\n        /// Current position in output stream.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mCurrentPosition = 0;\n        /// <summary>\n        /// Data length.\n        /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n        /// </summary>\n        this.mDataLength = 0;\n        /// <summary>\n        /// Specifies wheather next block can to be read.\n        /// Reading can be denied because the header of the last block have been read.\n        /// </summary>\n        this.mbCanReadNextBlock = true;\n        /// <summary>\n        /// Specifies wheather user can read more data from stream.\n        /// </summary>\n        this.mbCanReadMoreData = true;\n        /// <summary>\n        /// Specifies wheather checksum has been read.\n        /// </summary>\n        this.mbCheckSumRead = false;\n        if (stream == null) {\n            throw new DOMException('stream');\n        }\n        if (stream.length === 0) {\n            throw new DOMException('stream - string can not be empty');\n        }\n        DecompressorHuffmanTree.init();\n        this.mInputStream = new Stream(stream);\n        this.mbNoWrap = bNoWrap;\n        if (!this.mbNoWrap) {\n            this.readZLibHeader();\n        }\n        this.decodeBlockHeader();\n    }\n    Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n        get: function () {\n            return this.tBuffer;\n        },\n        set: function (value) {\n            this.tBuffer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    /// <summary>\n    /// Reads specified count of bits without adjusting position.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>Read value.</returns>\n    CompressedStreamReader.prototype.peekBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count > 32) {\n            throw new DOMException('count', 'Count of bits is too large.');\n        }\n        // If buffered data is not enough to give result,\n        // fill buffer.\n        if (this.mBufferedBits < count) {\n            this.fillBuffer();\n        }\n        // If you want to read 4 bytes and there is partial data in\n        // buffer, than you will fail.\n        if (this.mBufferedBits < count) {\n            return -1;\n        }\n        // Create bitmask for reading of count bits\n        var bitMask = ~(4294967295 << count);\n        var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);\n        //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n        return result;\n    };\n    CompressedStreamReader.prototype.fillBuffer = function () {\n        var length = 4 - (this.mBufferedBits >> 3) -\n            (((this.mBufferedBits & 7) !== 0) ? 1 : 0);\n        if (length === 0) {\n            return;\n        }\n        //TODO: fix this\n        var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n        for (var i = 0; i < bytesRead; i++) {\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer |\n                (Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits)));\n            this.mBufferedBits += 8;\n        }\n        //TODO: fix this\n    };\n    /// <summary>\n    /// Skips specified count of bits.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be skipped.</param>\n    CompressedStreamReader.prototype.skipBits = function (count) {\n        if (count < 0) {\n            throw new DOMException('count', 'Bits count can not be less than zero.');\n        }\n        if (count === 0) {\n            return;\n        }\n        if (count >= this.mBufferedBits) {\n            count -= this.mBufferedBits;\n            this.mBufferedBits = 0;\n            this.mBuffer = 0;\n            // if something left, skip it.\n            if (count > 0) {\n                // Skip entire bytes.\n                this.mInputStream.position += (count >> 3); //TODO: fix this\n                count &= 7;\n                // Skip bits.\n                if (count > 0) {\n                    this.fillBuffer();\n                    this.mBufferedBits -= count;\n                    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n                }\n            }\n        }\n        else {\n            this.mBufferedBits -= count;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n    };\n    Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n        get: function () {\n            return this.mBufferedBits;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// <summary>\n    /// Reads ZLib header with compression method and flags.\n    /// </summary>\n    CompressedStreamReader.prototype.readZLibHeader = function () {\n        // first 8 bits - compression Method and flags\n        // 8 other - flags\n        var header = this.readInt16();\n        //Debug.WriteLine( BitsToString( header ) );\n        if (header === -1) {\n            throw new DOMException('Header of the stream can not be read.');\n        }\n        if (header % 31 !== 0) {\n            throw new DOMException('Header checksum illegal');\n        }\n        if ((header & this.DEF_HEADER_METHOD_MASK) !== (8 << 8)) {\n            throw new DOMException('Unsupported compression method.');\n        }\n        this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n        if (this.mWindowSize > 65535) {\n            throw new DOMException('Unsupported window size for deflate compression method.');\n        }\n        if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n            // Get dictionary.\n            throw new DOMException('Custom dictionary is not supported at the moment.');\n        }\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16 = function () {\n        var result = (this.readBits(8) << 8);\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Reads specified count of bits from stream.\n    /// </summary>\n    /// <param name=\"count\">Count of bits to be read.</param>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readBits = function (count) {\n        var result = this.peekBits(count);\n        if (result === -1) {\n            return -1;\n        }\n        this.mBufferedBits -= count;\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        return result;\n    };\n    /// <summary>\n    /// Reads and decodes block of data.\n    /// </summary>\n    /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n    CompressedStreamReader.prototype.decodeBlockHeader = function () {\n        if (!this.mbCanReadNextBlock) {\n            return false;\n        }\n        var bFinalBlock = this.readBits(1);\n        if (bFinalBlock === -1) {\n            return false;\n        }\n        var blockType = this.readBits(2);\n        if (blockType === -1) {\n            return false;\n        }\n        this.mbCanReadNextBlock = (bFinalBlock === 0);\n        //      ChecksumReset();\n        switch (blockType) {\n            case 0:\n                // Uncompressed data\n                this.mbReadingUncompressed = true;\n                this.skipToBoundary();\n                var length_1 = this.readInt16Inverted();\n                var lengthComplement = this.readInt16Inverted();\n                if (length_1 !== (lengthComplement ^ 0xffff)) {\n                    throw new DOMException('Wrong block length.');\n                }\n                if (length_1 > 65535) {\n                    throw new DOMException('Uncompressed block length can not be more than 65535.');\n                }\n                this.mUncompressedDataLength = length_1;\n                this.mCurrentLengthTree = null;\n                this.mCurrentDistanceTree = null;\n                break;\n            case 1:\n                // Compressed data with fixed huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n                this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n                break;\n            case 2:\n                // Compressed data with dynamic huffman codes.\n                this.mbReadingUncompressed = false;\n                this.mUncompressedDataLength = -1;\n                var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n                this.mCurrentLengthTree = trees.lengthTree;\n                this.mCurrentDistanceTree = trees.distanceTree;\n                break;\n            default:\n                throw new DOMException('Wrong block type.');\n        }\n        return true;\n    };\n    /// <summary>\n    /// Discards left-most partially used byte.\n    /// </summary>\n    CompressedStreamReader.prototype.skipToBoundary = function () {\n        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n        this.mBufferedBits &= ~7;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt16Inverted = function () {\n        var result = (this.readBits(8));\n        result |= this.readBits(8) << 8;\n        return result;\n    };\n    /// <summary>\n    /// Reades dynamic huffman codes from block header.\n    /// </summary>\n    /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n    /// <param name=\"distanceTree\">Distances tree.</param>\n    CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n        var bLastSymbol = 0;\n        var iLengthsCount = this.readBits(5);\n        var iDistancesCount = this.readBits(5);\n        var iCodeLengthsCount = this.readBits(4);\n        if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n            throw new DOMException('Wrong dynamic huffman codes.');\n        }\n        iLengthsCount += 257;\n        iDistancesCount += 1;\n        var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n        var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n        var arrDecoderCodeLengths = new Uint8Array(19);\n        iCodeLengthsCount += 4;\n        var iCurrentCode = 0;\n        while (iCurrentCode < iCodeLengthsCount) {\n            var len = this.readBits(3);\n            if (len < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n        }\n        var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n        iCurrentCode = 0;\n        for (;;) {\n            var symbol = void 0;\n            var bNeedBreak = false;\n            symbol = treeInternalDecoder.unpackSymbol(this);\n            while ((symbol & ~15) === 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n                if (iCurrentCode === iResultingCodeLengthsCount) {\n                    bNeedBreak = true;\n                    break;\n                }\n                symbol = treeInternalDecoder.unpackSymbol(this);\n            }\n            if (bNeedBreak) {\n                break;\n            }\n            if (symbol < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            if (symbol >= 17) {\n                bLastSymbol = 0;\n            }\n            else if (iCurrentCode === 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            var miRepSymbol = symbol - 16;\n            var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n            var count = this.readBits(bits);\n            if (count < 0) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n            if (iCurrentCode + count > iResultingCodeLengthsCount) {\n                throw new DOMException('Wrong dynamic huffman codes.');\n            }\n            while (count-- > 0) {\n                arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n            }\n            if (iCurrentCode === iResultingCodeLengthsCount) {\n                break;\n            }\n        }\n        var tempArray = new Uint8Array(iLengthsCount);\n        tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);\n        //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n        lengthTree = new DecompressorHuffmanTree(tempArray);\n        tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);\n        //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n        distanceTree = new DecompressorHuffmanTree(tempArray);\n        return { 'lengthTree': lengthTree, 'distanceTree': distanceTree };\n    };\n    /// <summary>\n    /// Decodes huffman codes.\n    /// </summary>\n    /// <returns>True if some data was read.</returns>\n    CompressedStreamReader.prototype.readHuffman = function () {\n        var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n        var dataRead = false;\n        //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n        var readdata = {};\n        // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n        // if we should not, we will have buffer overrun.\n        while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n            var symbol = void 0;\n            symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            // Only codes 0..255 are valid independent symbols.\n            while (((symbol) & ~0xff) === 0) {\n                readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n                dataRead = true;\n                if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n                    return true;\n                }\n                //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n                symbol = this.mCurrentLengthTree.unpackSymbol(this);\n            }\n            if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n                if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n                    throw new DOMException('Illegal code.');\n                }\n                var numDataRead = dataRead ? 1 : 0;\n                this.mbCanReadMoreData = this.decodeBlockHeader();\n                var numReadMore = (this.mbCanReadMoreData) ? 1 : 0;\n                return (numDataRead | numReadMore) ? true : false;\n            }\n            if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n                throw new DOMException('Illegal repeat code length.');\n            }\n            var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol -\n                this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatLength += extra;\n            }\n            // Unpack repeat distance.\n            symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n            if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n                throw new DOMException('Wrong distance code.');\n            }\n            var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n            iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n            if (iRepeatExtraBits > 0) {\n                var extra = this.readBits(iRepeatExtraBits);\n                if (extra < 0) {\n                    throw new DOMException('Wrong data.');\n                }\n                iRepeatDistance += extra;\n            }\n            // Copy data in slow repeat mode\n            for (var i = 0; i < iRepeatLength; i++) {\n                this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] =\n                    this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n                this.mDataLength++;\n                free--;\n            }\n            dataRead = true;\n        }\n        return dataRead;\n    };\n    /// <summary>\n    /// Reads data to buffer.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer for data.</param>\n    /// <param name=\"offset\">Offset in output data.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read.</returns>\n    CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n        }\n        if (length < 0 || length > buffer.length - offset) {\n            throw new DOMException('length', 'Length is illegal.');\n        }\n        var initialLength = length;\n        while (length > 0) {\n            // Read from internal buffer.\n            if (this.mCurrentPosition < this.mDataLength) {\n                // Position in buffer array.\n                var inBlockPosition = (this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE);\n                // We can not read more than we have in buffer at once,\n                // and we not read more than till the array end.\n                var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, (this.mDataLength - this.mCurrentPosition));\n                // Reading not more, than the rest of the buffer.\n                dataToCopy = Math.min(dataToCopy, length);\n                //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n                // Copy data.\n                //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n                //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n                Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);\n                // Correct position, length,\n                this.mCurrentPosition += dataToCopy;\n                offset += dataToCopy;\n                length -= dataToCopy;\n            }\n            else {\n                if (!this.mbCanReadMoreData) {\n                    break;\n                }\n                var oldDataLength = this.mDataLength;\n                if (!this.mbReadingUncompressed) {\n                    if (!this.readHuffman()) {\n                        break;\n                    }\n                }\n                else {\n                    if (this.mUncompressedDataLength === 0) {\n                        // If there is no more data in stream, just exit.\n                        this.mbCanReadMoreData = this.decodeBlockHeader();\n                        if (!(this.mbCanReadMoreData)) {\n                            break;\n                        }\n                    }\n                    else {\n                        // Position of the data end in block buffer.\n                        var inBlockPosition = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                        var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n                        var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n                        if (dataToRead !== dataRead) {\n                            throw new DOMException('Not enough data in stream.');\n                        }\n                        this.mUncompressedDataLength -= dataRead;\n                        this.mDataLength += dataRead;\n                    }\n                }\n                if (oldDataLength < this.mDataLength) {\n                    var start = (oldDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    var end = (this.mDataLength % this.DEF_MAX_WINDOW_SIZE);\n                    if (start < end) {\n                        this.checksumUpdate(this.mBlockBuffer, start, end - start);\n                    }\n                    else {\n                        this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n                        if (end > 0) {\n                            this.checksumUpdate(this.mBlockBuffer, 0, end);\n                        }\n                    }\n                }\n            }\n        }\n        if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n            this.skipToBoundary();\n            var checkSum = this.readInt32();\n            //Debug.Assert( checkSum == mCheckSum, \"\" );\n            if (checkSum !== this.mCheckSum) {\n                throw new DOMException('Checksum check failed.');\n            }\n            this.mbCheckSumRead = true;\n        }\n        return initialLength - length;\n    };\n    /// <summary>\n    /// Reads array of bytes.\n    /// </summary>\n    /// <param name=\"buffer\">Output buffer.</param>\n    /// <param name=\"offset\">Offset in output buffer.</param>\n    /// <param name=\"length\">Length of the data to be read.</param>\n    /// <returns>Count of bytes actually read to the buffer.</returns>\n    CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n        if (buffer == null) {\n            throw new DOMException('buffer');\n        }\n        if (offset < 0 || offset > buffer.length - 1) {\n            throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n        }\n        if (length < 0) {\n            throw new DOMException('length\", \"Length can not be less than zero.');\n        }\n        if (length > buffer.length - offset) {\n            throw new DOMException('length\", \"Length is too large.');\n        }\n        if ((this.mBufferedBits & 7) !== 0) {\n            throw new DOMException('Reading of unalligned data is not supported.');\n        }\n        if (length === 0) {\n            return 0;\n        }\n        var result = 0;\n        while (this.mBufferedBits > 0 && length > 0) {\n            buffer[offset++] = (this.mBuffer);\n            this.mBufferedBits -= 8;\n            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n            length--;\n            result++;\n        }\n        if (length > 0) {\n            //TODO: Fix this.\n            result += this.mInputStream.read(buffer, offset, length);\n        }\n        return result;\n    };\n    /// <summary>\n    /// TODO: place correct comment here\n    /// </summary>\n    /// <returns>\n    /// TODO: place correct comment here\n    /// </returns>\n    CompressedStreamReader.prototype.readInt32 = function () {\n        var result = this.readBits(8) << 24;\n        result |= this.readBits(8) << 16;\n        result |= this.readBits(8) << 8;\n        result |= this.readBits(8);\n        return result;\n    };\n    /// <summary>\n    /// Updates checksum by calculating checksum of the\n    /// given buffer and adding it to current value.\n    /// </summary>\n    /// <param name=\"buffer\">Data byte array.</param>\n    /// <param name=\"offset\">Offset in the buffer.</param>\n    /// <param name=\"length\">Length of data to be used from the stream.</param>\n    CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n        ChecksumCalculator.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n    };\n    CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);\n    /// <summary>\n    /// Minimum count of repetions.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];\n    /// <summary>\n    /// Bits, that responds for different repetion modes.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];\n    /// <summary>\n    /// Length bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n    ];\n    /// <summary>\n    /// Length extended bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0\n    ];\n    /// <summary>\n    /// Distance bases.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n    ];\n    /// <summary>\n    /// Distance extanded bits count.\n    /// </summary>\n    CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13\n    ];\n    return CompressedStreamReader;\n}());\nexport { CompressedStreamReader };\nvar Stream = /** @class */ (function () {\n    function Stream(input) {\n        this.position = 0;\n        this.inputStream = new Uint8Array(input.buffer);\n    }\n    Object.defineProperty(Stream.prototype, \"length\", {\n        get: function () {\n            return this.inputStream.buffer.byteLength;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Stream.prototype.read = function (buffer, start, length) {\n        var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n        var data = temp.subarray(0, length);\n        buffer.set(data, 0);\n        this.position += data.byteLength;\n        return data.byteLength;\n    };\n    Stream.prototype.readByte = function () {\n        return this.inputStream[this.position++];\n    };\n    Stream.prototype.write = function (inputBuffer, offset, count) {\n        Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);\n        // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n        // this.inputStream.set(inputBuffer, offset);\n        this.position += count;\n    };\n    Stream.prototype.toByteArray = function () {\n        return new Uint8Array(this.inputStream.buffer);\n    };\n    return Stream;\n}());\nexport { Stream };\n/* eslint-enable */ \n"],"names":["Utils","bitReverse","value","reverseBits","bitConverterToInt32","index","bitConverterToInt16","bitConverterToUInt32","uint","Uint32Array","bitConverterToUInt16","Uint16Array","bitConverterUintToInt32","Int32Array","bitConverterInt32ToUint","bitConverterInt32ToInt16","Int16Array","byteToString","str","i","length","String","fromCharCode","byteIntToString","arrayCopy","source","sourceIndex","destination","destinationIndex","dataToCopy","data","Uint8Array","buffer","subarray","set","mergeArray","arrayOne","arrayTwo","mergedArray","encodedString","input","chr2","chr3","encode1","encode2","encode3","encode4","keyStr","count","resultIndex","totalLength","replace","charAt","Error","output","indexOf","huffCodeLengthOrders","CRC32TABLE","BufferSize","ZipArchive","Object","defineProperty","prototype","get","this","files","enumerable","configurable","level","undefined","addItem","item","file","ZipArchiveItem","name","push","addDirectory","directoryName","slice","getItem","contains","open","base64String","zipByteArray","DOMException","stream","Stream","lCentralDirEndPosition","findValueFromEnd","position","iCentralDirSize","ReadInt32","readCentralDirectoryDataAndExtractItems","itemHelper","ZipArchiveItemHelper","readCentralDirectoryData","readData","checkCrc","decompressData","unCompressedStream","save","fileName","zipArchive","Promise","resolve","reject","saveInternal","then","saveAsBlob","blob","skipFileSave","_this","zipData","dirLength","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","destroy","reader_1","FileReader","onload","result","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","compressData","length_1","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","CompressedStreamWriter","currentIndex","close","nextIndex","Math","min","subArray","write","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getBytes","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","type","Save","offset","externalFileAttribute","centralLength","localLength","a","j","charCodeAt","bytes","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","initCrc32Table","k","maxCount","lStreamSize","inputStream","byteLength","arrBuffer","lLastPos","max","lCurrentPosition","uiCurValue","read","bFound","readByte","ReadInt16","ReadUInt16","isMicrosoftBrowser","navigator","msSaveBlob","options","compressionMethod","crc32","originalSize","iFileNameLength","iExtraFieldLenth","iCommentLength","externalAttributes","localHeaderOffset","m_strItemName","readLocalHeader","readCompressedData","decompressDataOld","decompressedData","iReadBytes","reader","CompressedStreamReader","compressedStream","toByteArray","headerSignature","iNameLength","iExtraLength","iBytesLeft","dataStream","iBytesToRead","decompressedStream","itemName","ARR_LITERAL_CODES","ARR_LITERAL_LENGTHS","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","compressedString","apply","encode","end","Encoding","inputBuffer","inputOffset","inputEnd","noWrap","checkSum","ChecksumCalculator","checksumUpdate","pendingBufLength","pendingBufferFlush","writeZLibHeader","pendingBufferWriteShortBytes","headerDate","s","pendingBuffer","finish","fillWindow","canFlush","success","compressSlow","flush","lookAhead","lookAheadCompleted","stringStart","windowSize","slideWindow","prevMatch","matchStart","prevLen","matchLength","discardMatch","matchPreviousBest","matchPreviousAvailable","bufferPosition","huffmanIsFull","hashHead","insertString","maxDist","findLongestMatch","matchPrevAvail","huffmanTallyLit","dataWindow","huffmanTallyDist","huffmanFlushBlock","blockStart","len","lastBlock","more","totalBytesIn","updateHash","hashSize","m","hashPrevious","match","hash","currentHash","hashShift","hashMask","windowMask","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","limit","stringEnd","scanEnd1","scanEnd","literal","arrDistances","arrLiterals","treeLiteral","codeFrequencies","dist","lc","huffmanLengthCode","extraBits","floor","dc","huffmanDistanceCode","treeDistances","stored","storedOffset","storedLength","buildTree","calculateBLFreq","treeCodeLengths","blTreeCodes","codeLengths","CompressorHuffmanTree","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanSendAllTrees","huffmanCompressBlock","huffmanReset","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","bits","literalLen","writeCodeToStream","b","pendingBufCache","pendingBufBitsInCache","pendingBufferFlushBits","isClose","array","initHuffmanTree","isHuffmanTreeInitiated","codeCount","codeLength","codeFrequency","codes","lengths","temp","lengthTemp","writer","nextCode","maxLength","bitsCount","lengthCount","blTree","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentCodeLength","currentRepeatCount","codesCount","arrTree","n","freq","pos","pPos","codeMinCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","bitLength","childIndex","elementCount","minCodes","checksum","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","DecompressorHuffmanTree","init","m_LengthTree","m_DistanceTree","prepareData","blCount","treeSize","MAX_BITLEN","treeFromData","tree","pointer","revcode","treeLen","subTree","m_Tree","unpackSymbol","subtree","lookahead","symbol","peekBits","skipBits","availableBits","ChecksumUpdate","DEF_CHECKSUM_BIT_OFFSET","DEF_CHECKSUM_ITERATIONSCOUNT","DEF_CHECKSUM_BASE","ChecksumGenerate","tBuffer","mBufferedBits","fillBuffer","mBuffer","bytesRead","mInputStream","mTempBuffer","readZLibHeader","readInt16","DEF_HEADER_METHOD_MASK","mWindowSize","pow","DEF_HEADER_INFO_MASK","DEF_HEADER_FLAGS_FDICT","readBits","decodeBlockHeader","mbCanReadNextBlock","bFinalBlock","blockType","mbReadingUncompressed","skipToBoundary","readInt16Inverted","mUncompressedDataLength","mCurrentLengthTree","mCurrentDistanceTree","lengthTree","distanceTree","trees","decodeDynamicHeader","bLastSymbol","iLengthsCount","iDistancesCount","iCodeLengthsCount","iResultingCodeLengthsCount","arrResultingCodeLengths","arrDecoderCodeLengths","iCurrentCode","defaultHuffmanDynamicTree","treeInternalDecoder","bNeedBreak","miRepSymbol","DEF_HUFFMAN_DYNTREE_REPEAT_BITS","DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS","tempArray","readHuffman","free","DEF_MAX_WINDOW_SIZE","mDataLength","mCurrentPosition","dataRead","DEF_HUFFMAN_REPEATE_MAX","mBlockBuffer","DEF_HUFFMAN_LENGTH_MINIMUMCODE","DEF_HUFFMAN_END_BLOCK","numDataRead","mbCanReadMoreData","DEF_HUFFMAN_LENGTH_MAXIMUMCODE","iRepeatLength","DEF_HUFFMAN_REPEAT_LENGTH_BASE","iRepeatExtraBits","DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION","extra","DEF_HUFFMAN_REPEAT_DISTANCE_BASE","iRepeatDistance","DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION","initialLength","inBlockPosition","oldDataLength","dataToRead","readPackedBytes","start","mbCheckSumRead","mbNoWrap","readInt32","mCheckSum","DEF_REVERSE_BITS","bNoWrap","DEF_HEADER_FLAGS_FCHECK","DEF_HEADER_FLAGS_FLEVEL","DEF_HUFFMAN_DISTANCE_MAXIMUMCODE"],"mappings":"mRAIIA,EAAMC,WAAa,SAAUC,GACzB,OAAQF,EAAMG,YAAoB,GAARD,IAAe,GACnCF,EAAMG,YAAaD,GAAS,EAAK,KAAO,EACxCF,EAAMG,YAAaD,GAAS,EAAK,KAAO,EACxCF,EAAMG,YAAYD,GAAS,KAErCF,EAAMI,oBAAsB,SAAUF,EAAOG,GACzC,OAAOH,EAAMG,GAASH,EAAMG,EAAQ,IAAM,EAAIH,EAAMG,EAAQ,IAAM,GAAKH,EAAMG,EAAQ,IAAM,IAE/FL,EAAMM,oBAAsB,SAAUJ,EAAOG,GACzC,OAAOH,EAAMG,GAASH,EAAMG,EAAQ,IAAM,GAE9CL,EAAMO,qBAAuB,SAAUL,GACnC,IAAIM,EAAO,IAAIC,YAAY,CAAC,EAE5B,OADAD,EAAK,GAAKN,EACHM,EAAK,IAEhBR,EAAMU,qBAAuB,SAAUR,EAAOG,GAC1C,IAAIG,EAAO,IAAIG,YAAY,CAAC,EAE5B,OADAH,EAAK,GAAMN,EAAMG,GAASH,EAAMG,EAAQ,IAAM,EACvCG,EAAK,IAEhBR,EAAMY,wBAA0B,SAAUV,GACtC,IAAIM,EAAO,IAAIK,WAAW,CAAC,EAE3B,OADAL,EAAK,GAAKN,EACHM,EAAK,IAEhBR,EAAMc,wBAA0B,SAAUZ,GACtC,IAAIM,EAAO,IAAIC,YAAY,CAAC,EAE5B,OADAD,EAAK,GAAKN,EACHM,EAAK,IAEhBR,EAAMe,yBAA2B,SAAUb,GACvC,IAAIM,EAAO,IAAIQ,WAAW,CAAC,EAE3B,OADAR,EAAK,GAAKN,EACHM,EAAK,IAEhBR,EAAMiB,aAAe,SAAUf,GAE3B,IADA,IAAIgB,EAAM,GACDC,EAAI,EAAGA,EAAIjB,EAAMkB,OAAQD,CAAC,GAC/BD,GAAOG,OAAOC,aAAapB,EAAMiB,EAAE,EAEvC,OAAOD,GAEXlB,EAAMuB,gBAAkB,SAAUrB,GAE9B,IADA,IAAIgB,EAAM,GACDC,EAAI,EAAGA,EAAIjB,EAAMkB,OAAQD,CAAC,GAC/BD,GAAOG,OAAOC,aAAapB,EAAMiB,EAAE,EAEvC,OAAOD,GAEXlB,EAAMwB,UAAY,SAAUC,EAAQC,EAAaC,EAAaC,EAAkBC,GAExEC,EADO,IAAIC,WAAWN,EAAOO,OAAQN,CAAW,EACpCO,SAAS,EAAGJ,CAAU,EACtCF,EAAYO,IAAIJ,EAAMF,CAAgB,GAE1C5B,EAAMmC,WAAa,SAAUC,EAAUC,GACnC,IAAIC,EAAc,IAAIP,WAAWK,EAAShB,OAASiB,EAASjB,MAAM,EAGlE,OAFAkB,EAAYJ,IAAIE,CAAQ,EACxBE,EAAYJ,IAAIG,EAAUD,EAAShB,MAAM,EAClCkB,GAKXtC,EAAMuC,cAAgB,SAAUC,GAC5B,IAEIC,EACAC,EACAC,EACAC,EACAC,EACAC,EAPAC,EAAS,oEAQTC,EAAQ,EACRC,EAAc,EAGdC,EAA6B,GADjCV,EAAQA,EAAMW,QAAQ,sBAAuB,EAAE,GACvB/B,OAAa,EAOrC,GANIoB,EAAMY,OAAOZ,EAAMpB,OAAS,CAAC,IAAM2B,EAAOK,OAAO,EAAE,GACnDF,CAAW,GAEXV,EAAMY,OAAOZ,EAAMpB,OAAS,CAAC,IAAM2B,EAAOK,OAAO,EAAE,GACnDF,CAAW,GAEXA,EAAc,GAAM,EAOpB,MAAM,IAAIG,MAAM,2CAA2C,EAG/D,IADA,IAAIC,EAAS,IAAIvB,WAAyB,EAAdmB,CAAe,EACpCF,EAAQR,EAAMpB,QACjBuB,EAAUI,EAAOQ,QAAQf,EAAMY,OAAOJ,CAAK,EAAE,CAAC,EAK9CP,GAAmB,IAJnBG,EAAUG,EAAOQ,QAAQf,EAAMY,OAAOJ,CAAK,EAAE,CAAC,KAIpB,GAH1BH,EAAUE,EAAOQ,QAAQf,EAAMY,OAAOJ,CAAK,EAAE,CAAC,IAGH,EAC3CN,GAAmB,EAAVG,IAAgB,GAHzBC,EAAUC,EAAOQ,QAAQf,EAAMY,OAAOJ,CAAK,EAAE,CAAC,GAI9CM,EAAOL,CAAW,IAHVN,GAAW,EAAMC,GAAW,EAIpB,KAAZC,IACAS,EAAOL,CAAW,IAAMR,GAEZ,KAAZK,IACAQ,EAAOL,CAAW,IAAMP,GAGhC,OAAOY,GAEXtD,EAAMG,YAAc,CAAC,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IACvEH,EAAMwD,qBAAuB,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,QArH5FxD,EAsHOA,EArHP,SAASA,KCEb,IAAIyD,EAAa,GAwBbC,EAAa,KAWbC,GAYAC,OAAOC,eAAeF,EAAWG,UAAW,QAAS,CACjDC,IAAK,WACD,OAAOC,KAAKC,OAEhBC,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAeF,EAAWG,UAAW,mBAAoB,CAI5DC,IAAK,WACD,OAAOC,KAAKI,OAKhBlC,IAAK,SAAUkC,GACXJ,KAAKI,MAAQA,GAEjBF,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAeF,EAAWG,UAAW,SAAU,CAIlDC,IAAK,WACD,OAAmBM,KAAAA,IAAfL,KAAKC,MACE,EAEJD,KAAKC,MAAM7C,QAEtB8C,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAMDR,EAAWG,UAAUQ,QAAU,SAAUC,GACrC,GAAIA,MAAAA,EACA,MAAM,IAAIlB,MAAM,qDAAqD,EAEzE,IAAK,IAAIlC,EAAI,EAAGA,EAAI6C,KAAKC,MAAM7C,OAAQD,CAAC,GAAI,CACxC,IAAIqD,EAAOR,KAAKC,MAAM9C,GACtB,GAAIqD,aAAgBC,GACZD,EAAKE,OAASH,EAAKG,KACnB,MAAM,IAAIrB,MAAM,mCAAmC,EAI/DW,KAAKC,MAAMU,KAAKJ,CAAI,GAOxBZ,EAAWG,UAAUc,aAAe,SAAUC,GAC1C,GAAIA,MAAAA,EACA,MAAM,IAAIxB,MAAM,uDAAuD,EAE3E,GAA6B,IAAzBwB,EAAczD,OACd,MAAM,IAAIiC,MAAM,2CAA2C,EAK/D,GAHgC,MAA5BwB,EAAcC,MAAM,CAAC,CAAC,IACtBD,GAAiB,KAEqB,CAAC,IAAvCb,KAAKC,MAAMV,QAAQsB,CAAa,EAChC,MAAM,IAAIxB,MAAM,mCAAmC,EAEvDW,KAAKC,MAAMU,KAAKE,CAAa,GAOjClB,EAAWG,UAAUiB,QAAU,SAAU1E,GACrC,GAAa,GAATA,GAAcA,EAAQ2D,KAAKC,MAAM7C,OACjC,OAAO4C,KAAKC,MAAM5D,IAS1BsD,EAAWG,UAAUkB,SAAW,SAAUT,GACtC,MAAoC,CAAC,IAA9BP,KAAKC,MAAMV,QAAQgB,CAAI,GAElCZ,EAAWG,UAAUmB,KAAO,SAAUC,GAG9BC,EAAenF,EAAMuC,cAAc2C,CAAY,EACnD,GAA2B,GAAvBC,EAAa/D,OACb,MAAM,IAAIgE,aAAa,QAAQ,EACnC,IAAIC,EAAS,IAAIC,EAAOH,CAAY,EAEhCI,EAAyB5B,EAAW6B,iBAAiBH,EAzI9B,UAyIoE,KAAK,EACpG,GAAIE,EAAyB,EACzB,MAAM,IAAIH,aAAa,iGAAiG,EAE5HC,EAAOI,SAAWF,EAzIC,GA0InB,IAAIG,EAAkB/B,EAAWgC,UAAUN,CAAM,EAGjDA,EAAOI,SAFmBF,EAAyBG,EAGnD1B,KAAK4B,wCAAwCP,CAAM,GAgCvD1B,EAAWG,UAAU8B,wCAA0C,SAAUP,GACrE,GAAc,MAAVA,EACA,MAAM,IAAID,aAAa,QAAQ,EAEnC,IADA,IAAIS,EA7KiB,UA8KdlC,EAAWgC,UAAUN,CAAM,IAC9BQ,EAAa,IAAIC,GACNC,yBAAyBV,CAAM,EAM9CQ,EAAWG,SAASX,EAAQQ,EAAWI,QAAQ,EAC/CJ,EAAWK,iBACXlC,KAAKC,MAAMU,KAAK,IAAIF,EAAeoB,EAAWM,mBAAmBnE,OAAQ6D,EAAWnB,IAAI,CAAC,GAO7Ff,EAAWG,UAAUsC,KAAO,SAAUC,GAClC,GAAIA,MAAAA,GAAmE,IAApBA,EAASjF,OACxD,MAAM,IAAIiC,MAAM,yDAAyD,EAE7E,GAA0B,IAAtBW,KAAKC,MAAM7C,OACX,MAAM,IAAIiC,MAAM,kBAAkB,EAEtC,IAAIiD,EAAatC,KAEjB,OAAiB,IAAIuC,QAAQ,SAAUC,EAASC,GAC5CH,EAAWI,aAAaL,EAAU,CAAA,CAAK,EAAEM,KAAK,WAC1CH,EAAQF,CAAU,EACrB,EACJ,GAML3C,EAAWG,UAAU8C,WAAa,WAC9B,IAAIN,EAAatC,KAEjB,OAAiB,IAAIuC,QAAQ,SAAUC,EAASC,GAC5CH,EAAWI,aAAa,GAAI,CAAA,CAAI,EAAEC,KAAK,SAAUE,GAC7CL,EAAQK,CAAI,EACf,EACJ,GAELlD,EAAWG,UAAU4C,aAAe,SAAUL,EAAUS,GACpD,IAAIC,EAAQ/C,KACRsC,EAAatC,KAEjB,OAAiB,IAAIuC,QAAQ,SAAUC,EAASC,GAG5C,IAFA,IAAIO,EAAU,GACVC,EAAY,EACP9F,EAAI,EAAGA,EAAImF,EAAWrC,MAAM7C,OAAQD,CAAC,GACnB4F,EAAMG,kBAAkBH,EAAM9C,MAAM9C,EAAE,EAC5CwF,KAAK,SAAU7E,GAC5BmF,EAAYX,EAAWa,sBAAsBH,EAASlF,EAAMmF,EAAWnF,EAAKsF,WAAW,EACnFJ,EAAQ5F,SAAWkF,EAAWrC,MAAM7C,SAChCyF,EAAOP,EAAWe,mBAAmBhB,EAAUW,EAASC,EAAWH,CAAY,EACnFN,EAAQK,CAAI,GAEnB,EAER,GAMLlD,EAAWG,UAAUwD,QAAU,WAC3B,GAAmBjD,KAAAA,IAAfL,KAAKC,OAA2C,EAApBD,KAAKC,MAAM7C,OAAY,CACnD,IAAK,IAAID,EAAI,EAAGA,EAAI6C,KAAKC,MAAM7C,OAAQD,CAAC,GAAI,CACxC,IAAIqD,EAAOR,KAAKC,MAAM9C,GAClBqD,aAAgBC,GAChBD,EAAK8C,UAET9C,EAAOH,KAAAA,EAEXL,KAAKC,MAAQ,GAEjBD,KAAKC,MAAQI,KAAAA,EACbL,KAAKI,MAAQC,KAAAA,GAEjBV,EAAWG,UAAUoD,kBAAoB,SAAU3C,GAC/C,IAAI+B,EAAatC,KAsCjB,OArCc,IAAIuC,QAAQ,SAAUC,EAASC,GACzC,IACQc,EADJhD,aAAgBE,IACZ8C,EAAW,IAAIC,YACVC,OAAS,WACd,IAAIjF,EAAQ,IAAIT,WAAWwF,EAASG,MAAM,EACtC5F,EAAO,CACPuE,SAAU9B,EAAKG,KAAMiD,WAAY,EAAGC,eAAgB,GACpDC,eAAgBxD,KAAAA,EAAWyD,qBAAsBtF,EAAMpB,OAAQ2G,gBAAiB1D,KAAAA,EAChF+C,YAAa,CAAA,GAEjB,GAAyB,WAArBd,EAAWlC,MAAoB,CAC/BkC,EAAW0B,aAAaxF,EAAOV,EAAM2B,CAAU,EAE/C,IADA,IAAIwE,EAAW,EACN9G,EAAI,EAAGA,EAAIW,EAAK8F,eAAexG,OAAQD,CAAC,GAC7C8G,GAAYnG,EAAK8F,eAAezG,GAAGC,OAEvCU,EAAK+F,eAAiBI,EACtBnG,EAAKiG,gBAAkB,YAGvBjG,EAAK+F,eAAiBrF,EAAMpB,OAC5BU,EAAK6F,WAAarB,EAAW4B,oBAAoB,EAAG1F,EAAOiB,CAAU,EACrE3B,EAAKiG,gBAAkB,OACvBjG,EAAK8F,eAAejD,KAAKnC,CAAK,EAElCgE,EAAQ1E,CAAI,GAEhByF,EAASY,kBAAkB5D,EAAKzC,IAAI,GAOpC0E,EAJW,CACPH,SAAU9B,EAAMoD,WAAY,EAAGC,eAAgB,GAAIC,eAAgB,EAAGC,qBAAsB,EAC5FC,gBAAiB,OAAYX,YAAa,CAAA,EAElC,EAEnB,GAGLzD,EAAWG,UAAUkE,aAAe,SAAUxF,EAAOV,EAAMsG,GACvD,IAAIC,EAAa,IAAIC,EAAuB,CAAA,CAAI,EAC5CC,EAAe,EAEnB,EAAG,CACC,GAAIA,GAAgB/F,EAAMpB,OAAQ,CAC9BiH,EAAWG,QACX,MAGJ,IADAC,EAAYC,KAAKC,IAAInG,EAAMpB,OAAQmH,EAAe,KAAK,EACnDK,EAAWpG,EAAMP,SAASsG,EAAcE,CAAS,QACrD3G,EAAK6F,WAAa3D,KAAKkE,oBAAoBpG,EAAK6F,WAAYiB,EAAUR,CAAU,EAChFC,EAAWQ,MAAMD,EAAU,EAAGH,EAAYF,CAAY,GACtDA,EAAeE,IACMjG,EAAMpB,QAC/BU,EAAK8F,eAAiBS,EAAWT,eACjCS,EAAWf,WAEf3D,EAAWG,UAAUqD,sBAAwB,SAAU2B,EAAUhH,EAAMmF,EAAWG,GAC9E,IAAI2B,EAAc,EACdC,EAAO,IAAIC,KAKXC,GAJA9B,IACA2B,GAA4B,IAEhCA,KACa/E,KAAKmF,YAAYrH,EAAMkH,CAAI,GACpCI,EAAc,OAAeF,EAASpH,EAAKuE,SAC3CgD,EAAarF,KAAKsF,sBAAsBxH,EAAMoH,EAAQjC,EAAW8B,CAAW,EAEhF,OADAD,EAASnE,KAAK,CAAEyE,YAAaA,EAAaC,WAAYA,EAAYzB,eAAgB9F,EAAM,EACjFmF,EAAYmC,EAAYhI,OAASU,EAAK+F,gBAEjDlE,EAAWG,UAAUqF,YAAc,SAAUrH,EAAMkH,GAC/C,IAAIO,EAAY,GAUhB,OATAA,EAAa,WACAzH,EAAKiG,gBACL/D,KAAKwF,SAASxF,KAAKyF,gBAAgBT,CAAI,EAAG,CAAC,EAC3ChF,KAAKwF,SAASxF,KAAK0F,gBAAgBV,CAAI,EAAG,CAAC,EAC3ChF,KAAKwF,SAAS1H,EAAK6F,WAAY,CAAC,EAChC3D,KAAKwF,SAAS1H,EAAK+F,eAAgB,CAAC,EACpC7D,KAAKwF,SAAS1H,EAAKgG,qBAAsB,CAAC,EAC1C9D,KAAKwF,SAAS1H,EAAKuE,SAASjF,OAAQ,CAAC,EACrC4C,KAAKwF,SAAS,EAAG,CAAC,GAGnC7F,EAAWG,UAAUuD,mBAAqB,SAAUhB,EAAUW,EAAS2C,EAAa7C,GAGhF,IAFA,IAAI8C,EAAY,EACZ5H,EAAS,GACJb,EAAI,EAAGA,EAAI6F,EAAQ5F,OAAQD,CAAC,GAAI,CACrC,IAAIoD,EAAOyC,EAAQ7F,GAGnB,IAFAyI,GAAarF,EAAK8E,WAAWjI,OAC7BY,EAAO2C,KAAKX,KAAK6F,eAAetF,EAAK6E,WAAW,CAAC,EAC1C7E,EAAKqD,eAAeA,eAAexG,QACtCY,EAAO2C,KAAKJ,EAAKqD,eAAeA,eAAekC,QAAQ9H,MAAM,EAGrE,IAASb,EAAI,EAAGA,EAAI6F,EAAQ5F,OAAQD,CAAC,GACjCa,EAAO2C,KAAKX,KAAK6F,eAAe7C,EAAQ7F,GAAGkI,UAAU,CAAC,EAE1DrH,EAAO2C,KAAKX,KAAK6F,eAAe7F,KAAK+F,YAAY/C,EAAS4C,EAAWD,CAAW,CAAC,CAAC,EAC9E9C,EAAO,IAAImD,KAAKhI,EAAQ,CAAEiI,KAAM,kBAAmB,EAIvD,OAHKnD,GACDoD,OAAK9D,KAAKC,EAAUQ,CAAI,EAErBA,GAEXlD,EAAWG,UAAUwF,sBAAwB,SAAUxH,EAAMsH,EAAae,EAAQC,GAQ9E,MAPsB,OAClBpG,KAAKwF,SAAS,GAAQ,CAAC,EAAIJ,EAC3BpF,KAAKwF,SAAS,EAAG,CAAC,EACL,WACbxF,KAAKwF,SAASY,EAAuB,CAAC,EACtCpG,KAAKwF,SAASW,EAAQ,CAAC,EACvBrI,EAAKuE,UAGb1C,EAAWG,UAAUiG,YAAc,SAAU/C,EAASqD,EAAeC,GAKjE,MAJa,eACTtG,KAAKwF,SAASxC,EAAQ5F,OAAQ,CAAC,EAAI4C,KAAKwF,SAASxC,EAAQ5F,OAAQ,CAAC,EAClE4C,KAAKwF,SAASa,EAAe,CAAC,EAAIrG,KAAKwF,SAASc,EAAa,CAAC,EAC9DtG,KAAKwF,SAAS,EAAG,CAAC,GAG1B7F,EAAWG,UAAU+F,eAAiB,SAAUrH,GAE5C,IADA,IAAI+H,EAAI,IAAIxI,WAAWS,EAAMpB,MAAM,EAC1BoJ,EAAI,EAAGA,EAAIhI,EAAMpB,OAAQ,EAAEoJ,EAChCD,EAAEC,GAA2B,IAAtBhI,EAAMiI,WAAWD,CAAC,EAE7B,OAAOD,EAAEvI,QAEb2B,EAAWG,UAAU0F,SAAW,SAAUtJ,EAAOiK,GAE7C,IADA,IAAIO,EAAQ,GACHvJ,EAAI,EAAGA,EAAIgJ,EAAQhJ,CAAC,GACzBuJ,GAASrJ,OAAOC,aAAqB,IAARpB,CAAY,EACzCA,KAAkB,EAEtB,OAAOwK,GAEX/G,EAAWG,UAAU2F,gBAAkB,SAAUT,GAC7C,IAAI2B,EAAU3B,EAAK4B,WAInB,OADAD,IAFAA,IAAqB,GACD3B,EAAK6B,eACJ,GACM7B,EAAK8B,aAAe,GAEnDnH,EAAWG,UAAU4F,gBAAkB,SAAUV,GAC7C,IAAI+B,EAAW/B,EAAKgC,cAAgB,KAIpC,OADAD,IAFAA,IAAuB,GACA/B,EAAKiC,WAAa,IAClB,GACMjC,EAAKkC,WAEtCvH,EAAWG,UAAUoE,oBAAsB,SAAUP,EAAYnF,EAAO4F,GACpET,GAAc,CAAC,EACf,IAAK,IAAIxG,EAAI,EAAGA,EAAIqB,EAAMpB,OAAQD,CAAC,GAC/BwG,EAAcA,IAAe,EAAKS,EAAqC,KAAzBT,EAAanF,EAAMrB,KAErE,OAAuB,EAAfwG,GAMZhE,EAAWwH,eAAiB,WAExB,IADA,IACSX,EAAI,EAAGA,EAAI,IAAKA,CAAC,GAAI,CAE1B,IAAK,IADLrJ,EAAIqJ,EACKY,EAAI,EAAGA,EAAI,EAAGA,CAAC,GACpBjK,EAAU,EAAJA,EAAU,WAAcA,IAAM,EAAOA,IAAM,EAErDsC,EAAW+G,GAAKrJ,IAGxBwC,EAAW6B,iBAAmB,SAAUH,EAAQnF,EAAOmL,GACnD,GAAc,MAAVhG,EACA,MAAM,IAAID,aAAa,QAAQ,EAInC,IAAIkG,EAAcjG,EAAOkG,YAAYvJ,OAAOwJ,WAC5C,GAAIF,EAAc,EACd,MAAO,CAAC,EACZ,IAAIG,EAAY,IAAI1J,WAAW,CAAC,EAC5B2J,EAAWhD,KAAKiD,IAAI,EAAGL,EAAcD,CAAQ,EAC7CO,EAAmBN,EAAc,EAxc9B,EA2cHO,GAFJxG,EAAOI,SAAWmG,EAClBvG,EAAOyG,KAAKL,EAAW,EA1chB,CA0c2B,EACjBA,EAAU,IACvBM,EAAUF,GAAc3L,EAC5B,GAAI,CAAC6L,EACD,KAA0BL,EAAnBE,GAMH,GAJAC,IAAe,EAEfxG,EAAOI,SADPmG,EAAAA,GAEAC,GAAcxG,EAAO2G,aACH9L,EAAO,CACrB6L,EAAS,CAAA,EACT,MAIZ,OAAOA,EAASH,EAAmB,CAAC,GAOxCjI,EAAWgC,UAAY,SAAUN,GAC7B,IAAIrD,EAAS,IAAID,WAleV,CAke6B,EACpC,GAneO,GAmeHsD,EAAOyG,KAAK9J,EAAQ,EAnejB,CAme4B,EAC/B,MAAM,IAAIoD,aAAa,6EAA6E,EAExG,OAAOpF,EAAMI,oBAAoB4B,EAAQ,CAAC,GAO9C2B,EAAWsI,UAAY,SAAU5G,GAC7B,IAAIrD,EAAS,IAAID,WA1eR,CA0e6B,EACtC,GA3eS,GA2eLsD,EAAOyG,KAAK9J,EAAQ,EA3ef,CA2e4B,EACjC,MAAM,IAAIoD,aAAa,6EAA6E,EAExG,OAAOpF,EAAMM,oBAAoB0B,EAAQ,CAAC,GAO9C2B,EAAWuI,WAAa,SAAU7G,GAE1B,IAAIrD,EAAS,IAAID,WAvfZ,CAufiC,EACtC,GAxfK,GAwfDsD,EAAOyG,KAAK9J,EAAQ,EAxfnB,CAwfgC,EACjC,MAAM,IAAIoD,aAAa,6EAA6E,EAExG,OAAOpF,EAAMM,oBAAoB0B,EAAQ,CAAC,GAG3C2B,GA/dP,SAASA,IACqB,IAAtBF,EAAWrC,QACXuC,EAAWwH,iBAEfnH,KAAKC,MAAQ,GACbD,KAAKI,MAAQ,SACb8F,OAAKiC,mBAAqB,EAAGC,UAAUC,WAgf3CvG,EAAqBhC,UAAUiC,yBAA2B,SAAUV,GAEhEA,EAAOI,UAAY,EACnBzB,KAAKsI,QAAU3I,EAAWsI,UAAU5G,CAAM,EAC1CrB,KAAKuI,kBAAoB5I,EAAWsI,UAAU5G,CAAM,EACpDrB,KAAKiC,SAAsC,IAA1BjC,KAAKuI,kBAGH5I,EAAWgC,UAAUN,CAAM,EAE9CrB,KAAKwI,MAAQxM,EAAMO,qBAAqBoD,EAAWgC,UAAUN,CAAM,CAAC,EACpErB,KAAK6D,eAAiBlE,EAAWgC,UAAUN,CAAM,EACjDrB,KAAKyI,aAAe9I,EAAWgC,UAAUN,CAAM,EAJ/C,IAKIqH,EAAkB/I,EAAWsI,UAAU5G,CAAM,EAC7CsH,EAAmBhJ,EAAWsI,UAAU5G,CAAM,EAC9CuH,EAAiBjJ,EAAWsI,UAAU5G,CAAM,EAM5CoG,GAHJpG,EAAOI,UAAY,EACnBzB,KAAK6I,mBAAqBlJ,EAAWgC,UAAUN,CAAM,EACrDrB,KAAK8I,kBAAoBnJ,EAAWgC,UAAUN,CAAM,EACpC,IAAItD,WAAW2K,CAAe,GAC9CrH,EAAOyG,KAAKL,EAAW,EAAGiB,CAAe,EAEzCK,GAAgBA,EADI/M,EAAMiB,aAAawK,CAAS,GAClBtI,QAAQ,KAAM,GAAG,EAC/Ca,KAAKU,KAAOqI,EACZ1H,EAAOI,UAAYkH,EAAmBC,EAClB,GAAhB5I,KAAKsI,UACLtI,KAAKsI,QAAU,IAOvBxG,EAAqBhC,UAAUkC,SAAW,SAAUX,EAAQY,GACxD,GAAqB,GAAjBZ,EAAOjE,OACP,MAAM,IAAIgE,aAAa,QAAQ,EACnCC,EAAOI,SAAWzB,KAAK8I,kBACvB9I,KAAKiC,SAAWA,EAChBjC,KAAKgJ,gBAAgB3H,CAAM,EAC3BrB,KAAKiJ,mBAAmB5H,CAAM,GAElCS,EAAqBhC,UAAUoC,eAAiB,WACd,GAA1BlC,KAAKuI,mBACmB,EAApBvI,KAAKyI,cACLzI,KAAKkJ,qBAIjBpH,EAAqBhC,UAAUoJ,kBAAoB,WAQ/C,IAPA,IACIC,EAIAC,EALAC,EAAS,IAAIC,EAAuBtJ,KAAKuJ,iBAAkB,CAAA,CAAI,EAI/D9B,GAFoB,EAApBzH,KAAKyI,eACLU,EAAmB,IAAI7H,EAAO,IAAIvD,WAAWiC,KAAKyI,YAAY,CAAC,GACnD,IAAI1K,WAAW2B,CAAU,GAGqB,GAAtD0J,EAAaC,EAAOvB,KAAKL,EAAW,EAAG/H,CAAU,IAGrDyJ,EAAiBtE,MAAM4C,EAAUxJ,SAAS,EAAGmL,CAAU,EAAG,EAAGA,CAAU,EAE3EpJ,KAAKmC,mBAAqBgH,EAAiBK,cAMvCxJ,KAAKiC,UAUbH,EAAqBhC,UAAUkJ,gBAAkB,SAAU3H,GACvD,GAAqB,GAAjBA,EAAOjE,OACP,MAAM,IAAIgE,aAAa,QAAQ,EACnC,GAAIzB,EAAWgC,UAAUN,CAAM,GAAKrB,KAAKyJ,gBACrC,MAAM,IAAIrI,aAAa,2EAA2E,EAGtGC,EAAOI,UAAY,GACnB,IAAIiI,EAAc/J,EAAWsI,UAAU5G,CAAM,EACzCsI,EAAehK,EAAWuI,WAAW7G,CAAM,EAC/C,GAA8B,IAA1BrB,KAAKuI,kBAOJ,GAAmB,EAAfoB,EAAkB,CAGvB,GAFAtI,EAAOI,UAAYiI,EAEF,IADD/J,EAAWsI,UAAU5G,CAAM,EAEvC,MAAM,IAAID,aAAa,aAAa,EAEpCC,EAAOI,UAAYkI,EAAe,OAGtCtI,EAAOI,UAAYiI,EAAcC,GAMzC7H,EAAqBhC,UAAUmJ,mBAAqB,SAAU5H,GAE1D,GAA0B,EAAtBrB,KAAK6D,eAAoB,CAIzB,IAHA,IAAI+F,EAAa5J,KAAK6D,eACtBgG,EAAa,IAAIvI,EAAO,IAAIvD,WAAW6L,CAAU,CAAC,EAC9CnC,EAAY,IAAI1J,WAAW2B,CAAU,EACrB,EAAbkK,GAAgB,CACnB,IAAIE,EAAepF,KAAKC,IAAIiF,EAAYlK,CAAU,EAClD,GAAI2B,EAAOyG,KAAKL,EAAW,EAAGqC,CAAY,GAAKA,EAC3C,MAAM,IAAI1I,aAAa,6DAA6D,EACxFyI,EAAWhF,MAAM4C,EAAUxJ,SAAS,EAAG6L,CAAY,EAAG,EAAGA,CAAY,EACrEF,GAAcE,EAQlB9J,KAAKuJ,iBAAmB,IAAIxL,WAAW8L,EAAWtC,WAAW,OAGxDvH,KAAK6D,eAAiB,GAwBtB7D,KAAK6D,oBAjLlB/B,EAqLOA,EApLP,SAASA,IAIL9B,KAAKyJ,gBAAkB,SAKvBzJ,KAAKiC,SAAW,CAAA,EAIhBjC,KAAKwI,MAAQ,EAmMjB5I,OAAOC,eAAeY,EAAeX,UAAW,aAAc,CAC1DC,IAAK,WACD,OAAOC,KAAK+J,oBAEhB7J,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAeY,EAAeX,UAAW,OAAQ,CAKpDC,IAAK,WACD,OAAOC,KAAKqC,UAMhBnE,IAAK,SAAUhC,GACX8D,KAAKqC,SAAWnG,GAEpBgE,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAKDM,EAAeX,UAAUwD,QAAU,WAC/BtD,KAAKqC,SAAWhC,KAAAA,EAChBL,KAAKlC,KAAOuC,KAAAA,OAlDhBI,EAoDOA,EA9CP,SAASA,EAAe3C,EAAMkM,GAC1B,GAAIlM,MAAAA,EACA,MAAM,IAAIuB,MAAM,qDAAqD,EAEzE,GAAI2K,MAAAA,EACA,MAAM,IAAI3K,MAAM,uDAAuD,EAE3E,GAAwB,IAApB2K,EAAS5M,OACT,MAAM,IAAIiC,MAAM,wBAAwB,EAE5CW,KAAKlC,KAAOA,EACZkC,KAAKU,KAAOsJ,ECvtBpB,IAAIC,EAAoB,IAAIjN,WAAW,GAAG,EACtCkN,EAAsB,IAAInM,WAAW,GAAG,EACxCoM,EAAqB,IAAInN,WAAW,EAAE,EACtCoN,EAAuB,IAAIrM,WAAW,EAAE,EAUxCuG,GAiDA1E,OAAOC,eAAeyE,EAAuBxE,UAAW,iBAAkB,CAItEC,IAAK,WACD,OAAOC,KAAKqB,QAEhBnB,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAeyE,EAAuBxE,UAAW,sBAAuB,CAC3EC,IAAK,WACD,IAAIsK,EAAmB,GACvB,GAAoBhK,KAAAA,IAAhBL,KAAKqB,OACL,IAAK,IAAIlE,EAAI,EAAGA,EAAI6C,KAAKqB,OAAOjE,OAAQD,CAAC,GACrCkN,GAAoBhN,OAAOC,aAAagN,MAAM,KAAMtK,KAAKqB,OAAOlE,EAAE,EAG1E,OAAOkN,GAEXnK,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAQDmE,EAAuBxE,UAAU+E,MAAQ,SAAU/G,EAAMqI,EAAQ/I,GAC7D,GAAIU,MAAAA,EACA,MAAM,IAAIuB,MAAM,kDAAkD,EAEtE,IAKQkL,EALJC,EAAMrE,EAAS/I,EACnB,GAAQ+I,EAAJ,GAAuBqE,EAATrE,GAAgBqE,EAAM1M,EAAKV,OACzC,MAAM,IAAIiC,MAAM,4DAA4D,EAchF,IAZoB,UAAhB,OAAOvB,KACHyM,EAAS,IAAIE,WAAS,CAAA,CAAK,GACxBxE,KAAO,OAEduE,EAAMrE,GADNrI,EAAO,IAAIC,WAAWwM,EAAO/E,SAAS1H,EAAM,EAAGA,EAAKV,MAAM,CAAC,GACvCA,QAExB4C,KAAK0K,YAAc5M,EACnBkC,KAAK2K,YAAcxE,EACnBnG,KAAK4K,SAAWJ,EACXxK,KAAK6K,SACN7K,KAAK8K,SAAWC,EAAmBC,eAAehL,KAAK8K,SAAU9K,KAAK0K,YAAa1K,KAAK2K,YAAaH,CAAG,GAEnGxK,KAAK4K,WAAa5K,KAAK2K,aAA4C,IAA1B3K,KAAKiL,kBACnDjL,KAAKkL,qBACLlL,KAAKgE,aAAa,CAAA,CAAK,GAO/BM,EAAuBxE,UAAUqL,gBAAkB,WAQ/CnL,KAAKoL,6BAFLC,KAE4C,GAMhD/G,EAAuBxE,UAAUsL,6BAA+B,SAAUE,GACtEtL,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAMK,GAAK,EACnDtL,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAMK,GAElDhH,EAAuBxE,UAAUkE,aAAe,SAAUwH,GAEtD,EAAG,CACCxL,KAAKyL,aACL,IAAIC,EAAYF,GAAUxL,KAAK4K,WAAa5K,KAAK2K,YACjDgB,EAAU3L,KAAK4L,aAAaF,EAAUF,CAAM,QACb,IAA1BxL,KAAKiL,kBAA0BU,GACxC,OAAOA,GAEXrH,EAAuBxE,UAAU8L,aAAe,SAAUC,EAAOL,GAC7D,GAAIxL,KAAK8L,UAAY,KAAO,CAACD,EACzB,MAAO,CAAA,EAEX,KAAyB,KAAlB7L,KAAK8L,WAAoBD,GAAO,CACnC,GAAuB,IAAnB7L,KAAK8L,UACL,OAAO9L,KAAK+L,mBAAmBP,CAAM,EAErCxL,KAAKgM,aAAe,EAAIhM,KAAKiM,WAAa,KAC1CjM,KAAKkM,cAET,IAAIC,EAAYnM,KAAKoM,WACjBC,EAAUrM,KAAKsM,YAUnB,GATsB,GAAlBtM,KAAK8L,WACL9L,KAAKuM,eAEM,GAAXF,GAAgBrM,KAAKsM,aAAeD,EAC1BrM,KAAKwM,kBAAkBL,EAAWE,CAAO,EAGnDrM,KAAKyM,gCAELzM,KAAK0M,eACL,OAAO1M,KAAK2M,cAAcnB,CAAM,EAGxC,MAAO,CAAA,GAEXlH,EAAuBxE,UAAUyM,aAAe,WAC5C,IAAIK,EAAW5M,KAAK6M,eACH,IAAbD,GAAkB5M,KAAKgM,YAAcY,GAAY5M,KAAK8M,SAAW9M,KAAK+M,iBAAiBH,CAAQ,GAC3F5M,KAAKsM,aAAe,GAA2B,IAArBtM,KAAKsM,aAA0D,KAArCtM,KAAKgM,YAAchM,KAAKoM,aAC5EpM,KAAKsM,YAAc,IAI/BhI,EAAuBxE,UAAU2M,uBAAyB,WAClDzM,KAAKgN,gBACLhN,KAAKiN,gBAAwD,IAAxCjN,KAAKkN,WAAWlN,KAAKgM,YAAc,EAAS,EAErEhM,KAAKgN,eAAiB,CAAA,EACtBhN,KAAKgM,WAAW,GAChBhM,KAAK8L,SAAS,IAElBxH,EAAuBxE,UAAU0M,kBAAoB,SAAUL,EAAWE,GAGtE,IAFArM,KAAKmN,iBAAiBnN,KAAKgM,YAAc,EAAIG,EAAWE,CAAO,EAC/DA,GAAW,EAEPrM,KAAKgM,WAAW,GAChBhM,KAAK8L,SAAS,GACQ,GAAlB9L,KAAK8L,WACL9L,KAAK6M,eAEQ,EAAZ,EAAER,IAKX,OAJArM,KAAKgM,WAAW,GAChBhM,KAAK8L,SAAS,GACd9L,KAAKgN,eAAiB,CAAA,EACtBhN,KAAKsM,YAAc,EACZD,GAEX/H,EAAuBxE,UAAUiM,mBAAqB,SAAUP,GAO5D,OANIxL,KAAKgN,gBACLhN,KAAKiN,gBAAwD,IAAxCjN,KAAKkN,WAAWlN,KAAKgM,YAAc,EAAS,EAErEhM,KAAKgN,eAAiB,CAAA,EACtBhN,KAAKoN,kBAAkBpN,KAAKkN,WAAYlN,KAAKqN,WAAYrN,KAAKgM,YAAchM,KAAKqN,WAAY7B,CAAM,EACnGxL,KAAKqN,WAAarN,KAAKgM,YAChB,CAAA,GAEX1H,EAAuBxE,UAAU6M,cAAgB,SAAUnB,GACvD,IAAI8B,EAAMtN,KAAKgM,YAAchM,KAAKqN,WAI9BE,GAHAvN,KAAKgN,gBACLM,CAAG,GAEU9B,GAA6B,IAAnBxL,KAAK8L,WAAmB,CAAC9L,KAAKgN,gBAGzD,OAFAhN,KAAKoN,kBAAkBpN,KAAKkN,WAAYlN,KAAKqN,WAAYC,EAAKC,CAAS,EACvEvN,KAAKqN,YAAcC,EACZ,CAACC,GAEZjJ,EAAuBxE,UAAU2L,WAAa,WAI1C,IAHIzL,KAAKgM,aAAehM,KAAKiM,WAAajM,KAAK8M,SAC3C9M,KAAKkM,cAEFlM,KAAK8L,UAAY,KAAO9L,KAAK2K,YAAc3K,KAAK4K,UAAU,CAC7D,IAAI4C,EAAO,EAAIxN,KAAKiM,WAAajM,KAAK8L,UAAY9L,KAAKgM,YACnDwB,EAAOxN,KAAK4K,SAAW5K,KAAK2K,cAC5B6C,EAAOxN,KAAK4K,SAAW5K,KAAK2K,aAEhC3K,KAAKkN,WAAWhP,IAAI8B,KAAK0K,YAAYzM,SAAS+B,KAAK2K,YAAa3K,KAAK2K,YAAc6C,CAAI,EAAGxN,KAAKgM,YAAchM,KAAK8L,SAAS,EAC3H9L,KAAK2K,aAAe6C,EACpBxN,KAAKyN,cAAgBD,EACrBxN,KAAK8L,WAAa0B,EAEA,GAAlBxN,KAAK8L,WACL9L,KAAK0N,cAGbpJ,EAAuBxE,UAAUoM,YAAc,WAC3ClM,KAAKkN,WAAWhP,IAAI8B,KAAKkN,WAAWjP,SAAS+B,KAAKiM,WAAYjM,KAAKiM,WAAajM,KAAKiM,UAAU,EAAG,CAAC,EACnGjM,KAAKoM,YAAcpM,KAAKiM,WACxBjM,KAAKgM,aAAehM,KAAKiM,WACzBjM,KAAKqN,YAAcrN,KAAKiM,WACxB,IAAK,IAAI9O,EAAI,EAAGA,EAAI6C,KAAK2N,SAAU,EAAExQ,EAAG,CACpC,IAAIyQ,EAAuB,MAAnB5N,KAAK4M,SAASzP,GACtB6C,KAAK4M,SAASzP,GAAQyQ,GAAK5N,KAAKiM,WAAe2B,EAAI5N,KAAKiM,WAAc,EAE1E,IAAS9O,EAAI,EAAGA,EAAI6C,KAAKiM,WAAY9O,CAAC,GAAI,CAClCyQ,EAA2B,MAAvB5N,KAAK6N,aAAa1Q,GAC1B6C,KAAK6N,aAAa1Q,GAAOyQ,GAAK5N,KAAKiM,WAAe2B,EAAI5N,KAAKiM,WAAc,IAGjF3H,EAAuBxE,UAAU+M,aAAe,WAC5C,IAAIiB,EACAC,GAAS/N,KAAKgO,aAAehO,KAAKiO,UAAajO,KAAKkN,WAAWlN,KAAKgM,gBAA0BhM,KAAKkO,SAIvG,OAHAlO,KAAK6N,aAAa7N,KAAKgM,YAAchM,KAAKmO,YAAcL,EAAQ9N,KAAK4M,SAASmB,GAC9E/N,KAAK4M,SAASmB,GAAQ/N,KAAKgM,YAC3BhM,KAAKgO,YAAcD,EACJ,MAARD,GAEXxJ,EAAuBxE,UAAUiN,iBAAmB,SAAUqB,GAC1D,IAGIN,EAHAO,EAAW,KACXC,EAAU,IACVC,EAAOvO,KAAKgM,YAEZwC,EAAUxO,KAAKgM,YAAchM,KAAKsM,YAClCmC,EAAa/J,KAAKiD,IAAI3H,KAAKsM,YAAa,CAAK,EAC7CoC,EAAQhK,KAAKiD,IAAI3H,KAAKgM,YAAchM,KAAK8M,QAAS,CAAC,EACnD6B,EAAY3O,KAAKgM,YAAc,IAAM,EACrC4C,EAAW5O,KAAKkN,WAAWsB,EAAU,GACrCK,EAAU7O,KAAKkN,WAAWsB,GAC1B1Q,EAAOkC,KAAKkN,WACE,IAAduB,IACAJ,IAAa,GAEbC,EAAUtO,KAAK8L,YACfwC,EAAUtO,KAAK8L,WAEnB,GACI,GAAIhO,EAAKsQ,EAAWK,KAAgBI,GAChC/Q,EAAKsQ,EAAWK,EAAa,KAAOG,GACpC9Q,EAAKsQ,KAActQ,EAAKyQ,IACxBzQ,EAAKsQ,EAAW,KAAOtQ,EAAKyQ,EAAO,GAHvC,CASA,IAHAT,EAAQM,EAAW,EACnBG,GAAQ,EAEDzQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAAUhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAC7DhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAAUhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAC1DhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAAUhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAC1DhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAAUhQ,EAAK,EAAEyQ,KAAUzQ,EAAK,EAAEgQ,IAAUS,EAAOI,IAG/E,GAAWH,EAAPD,EAAgB,CAIhB,GAHAvO,KAAKoM,WAAagC,EAGAE,IADlBG,GADAD,EAAUD,GACUvO,KAAKgM,aAErB,MAEJ4C,EAAW9Q,EAAK0Q,EAAU,GAC1BK,EAAU/Q,EAAK0Q,GAEnBD,EAAOvO,KAAKgM,oBACNoC,EAA4D,MAAhDpO,KAAK6N,aAAaO,EAAWpO,KAAKmO,aAAyBO,GAAwB,GAAf,EAAEL,GAE5F,OADArO,KAAKsM,YAAc5H,KAAKC,IAAI8J,EAAYzO,KAAK8L,SAAS,EAC3B,GAApB9L,KAAKsM,aAEhBhI,EAAuBxE,UAAU4N,WAAa,WAC1C1N,KAAKgO,YAAehO,KAAKkN,WAAWlN,KAAKgM,cAAgBhM,KAAKiO,UAAajO,KAAKkN,WAAWlN,KAAKgM,YAAc,IAElH1H,EAAuBxE,UAAUmN,gBAAkB,SAAU6B,GAIzD,OAHA9O,KAAK+O,aAAa/O,KAAK0M,gBAAkB,EACzC1M,KAAKgP,YAAYhP,KAAK0M,cAAc,IAAMoC,EAC1C9O,KAAKiP,YAAYC,gBAAgBJ,EAAQ,UAClC9O,KAAK0M,gBAEhBpI,EAAuBxE,UAAUqN,iBAAmB,SAAUgC,EAAM7B,GAChEtN,KAAK+O,aAAa/O,KAAK0M,gBAAkByC,EACzCnP,KAAKgP,YAAYhP,KAAK0M,cAAc,IAAOY,EAAM,EAC7C8B,EAAKpP,KAAKqP,kBAAkB/B,EAAM,CAAC,EACvCtN,KAAKiP,YAAYC,gBAAgBE,EAAG,GAC1B,KAANA,GAAaA,EAAK,MAClBpP,KAAKsP,WAAa5K,KAAK6K,OAAOH,EAAK,KAAO,CAAC,GAE3CI,EAAKxP,KAAKyP,oBAAoBN,EAAO,CAAC,EAK1C,OAJAnP,KAAK0P,cAAcR,gBAAgBM,EAAG,GAC5B,GAANA,IACAxP,KAAKsP,WAAa5K,KAAK6K,MAAOC,EAAK,EAAI,WAEpCxP,KAAK0M,gBAEhBpI,EAAuBxE,UAAUsN,kBAAoB,SAAUuC,EAAQC,EAAcC,EAActC,GAC/FvN,KAAKiP,YAAYC,gBAAgB,IAAI,GACrClP,KAAKiP,YAAYa,YACjB9P,KAAK0P,cAAcI,YACnB9P,KAAKiP,YAAYc,gBAAgB/P,KAAKgQ,eAAe,EACrDhQ,KAAK0P,cAAcK,gBAAgB/P,KAAKgQ,eAAe,EACvDhQ,KAAKgQ,gBAAgBF,YAErB,IADA,IAAIG,EAAc,EACT9S,EAAI,GAAQ8S,EAAJ9S,EAAiBA,CAAC,GACuD,EAAlF6C,KAAKgQ,gBAAgBE,YAAYC,EAAsB3Q,qBAAqBrC,MAC5E8S,EAAc9S,EAAI,GAM1B,IAHA,IAAIiT,EAAU,GAAmB,EAAdH,EAAkBjQ,KAAKgQ,gBAAgBK,mBACtDrQ,KAAKiP,YAAYoB,mBAAqBrQ,KAAK0P,cAAcW,mBAAqBrQ,KAAKsP,UACnFgB,EAAatQ,KAAKsP,UACbnS,EAAI,EAAGA,EAAI,IAAKA,CAAC,GACtBmT,GAActQ,KAAKiP,YAAYC,gBAAgB/R,GAAK+M,EAAoB/M,GAE5E,IAASA,EAAI,EAAGA,EAAI,GAAIA,CAAC,GACrBmT,GAActQ,KAAK0P,cAAcR,gBAAgB/R,GAAKiN,EAAqBjN,GAEhEmT,GAAXF,IAEAA,EAAUE,GAEM,GAAhBV,GAAqBC,EAAe,EAAIO,GAAW,EACnDpQ,KAAKuQ,wBAAwBZ,EAAQC,EAAcC,EAActC,CAAS,GAErE6C,GAAWE,GAEhBtQ,KAAKwQ,uBAAuB,GAAYjD,EAAY,EAAI,GAAI,CAAC,EAC7DvN,KAAKiP,YAAYwB,eAAexG,EAAmBC,CAAmB,EACtElK,KAAK0P,cAAce,eAAetG,EAAoBC,CAAoB,IAK1EpK,KAAKwQ,uBAAuB,GAAYjD,EAAY,EAAI,GAAI,CAAC,EAC7DvN,KAAK0Q,oBAAoBT,CAAW,GACpCjQ,KAAK2Q,uBACL3Q,KAAK4Q,iBAGbtM,EAAuBxE,UAAUyQ,wBAA0B,SAAUZ,EAAQC,EAAcC,EAActC,GACrGvN,KAAKwQ,uBAAuB,GAAYjD,EAAY,EAAI,GAAI,CAAC,EAC7DvN,KAAK6Q,2BACL7Q,KAAK8Q,wBAAwBjB,CAAY,EACzC7P,KAAK8Q,wBAAwB,CAACjB,CAAY,EAC1C7P,KAAK+Q,4BAA4BpB,EAAQC,EAAcC,CAAY,EACnE7P,KAAK4Q,gBAETtM,EAAuBxE,UAAUuP,kBAAoB,SAAU/B,GAC3D,GAAY,MAARA,EACA,OAAO,IAGX,IADA,IAAI0D,EAAO,IACG,GAAP1D,GACH0D,GAAQ,EACR1D,IAAQ,EAEZ,OAAO0D,EAAO1D,GAElBhJ,EAAuBxE,UAAU2P,oBAAsB,SAAUwB,GAE7D,IADA,IAAID,EAAO,EACQ,GAAZC,GACHD,GAAQ,EACRC,IAAa,EAEjB,OAAOD,EAAOC,GAElB3M,EAAuBxE,UAAU4Q,oBAAsB,SAAUT,GAC7DjQ,KAAKgQ,gBAAgBkB,aACrBlR,KAAKiP,YAAYiC,aACjBlR,KAAK0P,cAAcwB,aACnBlR,KAAKwQ,uBAAuBxQ,KAAKiP,YAAYkC,WAAa,IAAK,CAAC,EAChEnR,KAAKwQ,uBAAuBxQ,KAAK0P,cAAcyB,WAAa,EAAG,CAAC,EAChEnR,KAAKwQ,uBAAuBP,EAAc,EAAG,CAAC,EAC9C,IAAK,IAAImB,EAAO,EAAGA,EAAOnB,EAAamB,CAAI,GACvCpR,KAAKwQ,uBAAuBxQ,KAAKgQ,gBAAgBE,YAAYC,EAAsB3Q,qBAAqB4R,IAAQ,CAAC,EAErHpR,KAAKiP,YAAYoC,UAAUrR,KAAKgQ,eAAe,EAC/ChQ,KAAK0P,cAAc2B,UAAUrR,KAAKgQ,eAAe,GAErD1L,EAAuBxE,UAAU8Q,aAAe,WAC5C5Q,KAAK0M,eAAiB,EACtB1M,KAAKsP,UAAY,EACjBtP,KAAKiP,YAAYqC,QACjBtR,KAAK0P,cAAc4B,QACnBtR,KAAKgQ,gBAAgBsB,SAEzBhN,EAAuBxE,UAAU6Q,qBAAuB,WACpD,IAAK,IAAIxT,EAAI,EAAGA,EAAI6C,KAAK0M,eAAgBvP,CAAC,GAAI,CAC1C,IAKQoU,EAIA/B,EATJgC,EAAmC,IAAtBxR,KAAKgP,YAAY7R,GAC9BgS,EAAOnP,KAAK+O,aAAa5R,GACd,GAAXgS,CAAI,IACAC,EAAKpP,KAAKqP,kBAAkBmC,CAAU,EAC1CxR,KAAKiP,YAAYwC,kBAAkBrC,CAAE,EAE1B,GADPmC,EAAO7M,KAAK6K,OAAOH,EAAK,KAAO,CAAC,IACpBmC,GAAQ,GACpBvR,KAAKwQ,uBAAuBgB,GAAe,GAAKD,GAAQ,EAAIA,CAAI,EAEhE/B,EAAKxP,KAAKyP,oBAAoBN,CAAI,EACtCnP,KAAK0P,cAAc+B,kBAAkBjC,CAAE,EAE5B,GADX+B,EAAO7M,KAAK6K,MAAMC,EAAK,EAAI,CAAC,IAExBxP,KAAKwQ,uBAAuBrB,GAAS,GAAKoC,GAAQ,EAAIA,CAAI,GAI9DvR,KAAKiP,YAAYwC,kBAAkBD,CAAU,EAGrDxR,KAAKiP,YAAYwC,kBAAkB,GAAG,GAO1CnN,EAAuBxE,UAAU0Q,uBAAyB,SAAUkB,EAAG1S,GACnE,IAAIxC,EAAO,IAAIC,YAAY,CAAC,EAC5BD,EAAK,GAAKwD,KAAK2R,gBAAmBD,GAAK1R,KAAK4R,sBAC5C5R,KAAK2R,gBAAkBnV,EAAK,GAC5BwD,KAAK4R,uBAAyB5S,EAC9BgB,KAAK6R,0BAETvN,EAAuBxE,UAAUoL,mBAAqB,SAAU4G,GAE5D,IACQC,EAFR/R,KAAK6R,yBACuB,EAAxB7R,KAAKiL,oBACD8G,EAAQ,IAAIhU,WAAWiC,KAAKiL,gBAAgB,GAC1C/M,IAAI8B,KAAKuL,cAActN,SAAS,EAAG+B,KAAKiL,gBAAgB,EAAG,CAAC,EAClEjL,KAAKqB,OAAOV,KAAKoR,CAAK,GAE1B/R,KAAKiL,iBAAmB,GAE5B3G,EAAuBxE,UAAU+R,uBAAyB,WAEtD,IADA,IAAInO,EAAS,EACwB,GAA9B1D,KAAK4R,uBAA8B5R,KAAKiL,wBAC3CjL,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAMjL,KAAK2R,gBACnD3R,KAAK2R,kBAAoB,EACzB3R,KAAK4R,uBAAyB,EAC9BlO,CAAM,GAEV,OAAOA,GAEXY,EAAuBxE,UAAUiR,4BAA8B,SAAUjT,EAAMqI,EAAQ/I,GAC/E2U,EAAQjU,EAAKG,SAASkI,EAAQA,EAAS/I,CAAM,EACjD4C,KAAKuL,cAAcrN,IAAI6T,EAAO/R,KAAKiL,gBAAgB,EACnDjL,KAAKiL,kBAAoB7N,GAE7BkH,EAAuBxE,UAAUgR,wBAA0B,SAAUxF,GACjEtL,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAMK,EAC9CtL,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAOK,GAAK,GAExDhH,EAAuBxE,UAAU+Q,yBAA2B,WACvB,EAA7B7Q,KAAK4R,wBACL5R,KAAKuL,cAAcvL,KAAKiL,gBAAgB,IAAMjL,KAAK2R,iBAEvD3R,KAAK2R,gBAAkB,EACvB3R,KAAK4R,sBAAwB,GAMjCtN,EAAuB0N,gBAAkB,WAErC,IADA,IAAI7U,EAAI,EACDA,EAAI,KACP8M,EAAkB9M,GAAKgT,EAAsBlU,WAAY,GAAQkB,GAAM,CAAC,EACxE+M,EAAoB/M,CAAC,IAAM,EAE/B,KAAOA,EAAI,KACP8M,EAAkB9M,GAAKgT,EAAsBlU,WAAY,IAAckB,GAAM,CAAC,EAC9E+M,EAAoB/M,CAAC,IAAM,EAE/B,KAAOA,EAAI,KACP8M,EAAkB9M,GAAKgT,EAAsBlU,WAAY,CAAA,IAAckB,GAAM,CAAC,EAC9E+M,EAAoB/M,CAAC,IAAM,EAE/B,KAAOA,EAAI,KACP8M,EAAkB9M,GAAKgT,EAAsBlU,WAAY,CAAA,GAAckB,GAAM,CAAC,EAC9E+M,EAAoB/M,CAAC,IAAM,EAE/B,IAAKA,EAAI,EAAGA,EAAI,GAAIA,CAAC,GACjBgN,EAAmBhN,GAAKgT,EAAsBlU,WAAWkB,GAAK,EAAE,EAChEiN,EAAqBjN,GAAK,GAOlCmH,EAAuBxE,UAAU0E,MAAQ,WACrC,KACIxE,KAAKkL,mBAAmB,CAAA,CAAI,EACvBlL,KAAKgE,aAAa,CAAA,CAAI,IACvBhE,KAAKkL,mBAAmB,CAAA,CAAI,EAC5BlL,KAAK6Q,2BACA7Q,KAAK6K,SACN7K,KAAKoL,6BAA6BpL,KAAK8K,UAAY,EAAE,EACrD9K,KAAKoL,6BAA6C,MAAhBpL,KAAK8K,QAAiB,GAE5D9K,KAAKkL,mBAAmB,CAAA,CAAI,GAEzBlL,KAAK4K,WAAa5K,KAAK2K,aACF,IAA1B3K,KAAKiL,qBAMf3G,EAAuBxE,UAAUwD,QAAU,WACvCtD,KAAKqB,OAAS,GACdrB,KAAKqB,OAAShB,KAAAA,EACdL,KAAKuL,cAAgBlL,KAAAA,EACrBL,KAAKiP,YAAc5O,KAAAA,EACnBL,KAAK0P,cAAgBrP,KAAAA,EACrBL,KAAKgQ,gBAAkB3P,KAAAA,EACvBL,KAAKgP,YAAc3O,KAAAA,EACnBL,KAAK+O,aAAe1O,KAAAA,EACpBL,KAAK4M,SAAWvM,KAAAA,EAChBL,KAAK6N,aAAexN,KAAAA,EACpBL,KAAKkN,WAAa7M,KAAAA,EAClBL,KAAK0K,YAAcrK,KAAAA,EACnBL,KAAKiL,iBAAmB5K,KAAAA,EACxBL,KAAK2R,gBAAkBtR,KAAAA,EACvBL,KAAK4R,sBAAwBvR,KAAAA,EAC7BL,KAAK0M,eAAiBrM,KAAAA,EACtBL,KAAKsP,UAAYjP,KAAAA,EACjBL,KAAKgO,YAAc3N,KAAAA,EACnBL,KAAKoM,WAAa/L,KAAAA,EAClBL,KAAKsM,YAAcjM,KAAAA,EACnBL,KAAKgN,eAAiB3M,KAAAA,EACtBL,KAAKqN,WAAahN,KAAAA,EAClBL,KAAKgM,YAAc3L,KAAAA,EACnBL,KAAK8L,UAAYzL,KAAAA,EACjBL,KAAKyN,aAAepN,KAAAA,EACpBL,KAAK2K,YAActK,KAAAA,EACnBL,KAAK4K,SAAWvK,KAAAA,EAChBL,KAAKiM,WAAa5L,KAAAA,EAClBL,KAAKmO,WAAa9N,KAAAA,EAClBL,KAAK2N,SAAWtN,KAAAA,EAChBL,KAAKkO,SAAW7N,KAAAA,EAChBL,KAAKiO,UAAY5N,KAAAA,EACjBL,KAAK8M,QAAUzM,KAAAA,EACfL,KAAK8K,SAAWzK,KAAAA,EAChBL,KAAK6K,OAASxK,KAAAA,GAElBiE,EAAuB2N,uBAAyB,CAAA,EACzC3N,GA5jBP,SAASA,EAAuBuG,GAC5B7K,KAAKuL,cAAgB,IAAIxN,WAAW,KAAO,EAC3CiC,KAAKiL,iBAAmB,EACxBjL,KAAK2R,gBAAkB,EACvB3R,KAAK4R,sBAAwB,EAC7B5R,KAAK0M,eAAiB,EACtB1M,KAAKsP,UAAY,EACjBtP,KAAKgO,YAAc,EACnBhO,KAAKoM,WAAa,EAClBpM,KAAKsM,YAAc,EACnBtM,KAAKgN,eAAiB,CAAA,EACtBhN,KAAKqN,WAAa,EAClBrN,KAAKgM,YAAc,EACnBhM,KAAK8L,UAAY,EACjB9L,KAAKyN,aAAe,EACpBzN,KAAK2K,YAAc,EACnB3K,KAAK4K,SAAW,EAChB5K,KAAKiM,WAAa,MAClBjM,KAAKmO,WAAanO,KAAKiM,WAAa,EACpCjM,KAAK2N,SAAW,MAChB3N,KAAKkO,SAAWlO,KAAK2N,SAAW,EAChC3N,KAAKiO,UAAYvJ,KAAK6K,MAAM,GAAe,CAAC,EAC5CvP,KAAK8M,QAAU9M,KAAKiM,WAAa,IACjCjM,KAAK8K,SAAW,EAChB9K,KAAK6K,OAAS,CAAA,EACTvG,EAAuB2N,yBACxB3N,EAAuB0N,kBACvB1N,EAAuB2N,uBAAyB,CAAA,GAEpDjS,KAAKiP,YAAc,IAAIkB,EAAsBnQ,KAAM,IAAK,IAAK,EAAE,EAC/DA,KAAK0P,cAAgB,IAAIS,EAAsBnQ,KAAM,GAAI,EAAG,EAAE,EAC9DA,KAAKgQ,gBAAkB,IAAIG,EAAsBnQ,KAAM,GAAI,EAAG,CAAC,EAC/DA,KAAK+O,aAAe,IAAIpS,mBACxBqD,KAAKgP,YAAc,IAAIjR,kBACvBiC,KAAKqB,OAAS,GACdrB,KAAKkN,WAAa,IAAInP,WAAW,EAAIiC,KAAKiM,UAAU,EACpDjM,KAAK4M,SAAW,IAAI5P,WAAWgD,KAAK2N,QAAQ,EAC5C3N,KAAK6N,aAAe,IAAI7Q,WAAWgD,KAAKiM,UAAU,EAClDjM,KAAKqN,WAAarN,KAAKgM,YAAc,GACrChM,KAAK6K,OAASA,IAEV7K,KAAKmL,kBAwiBbvL,OAAOC,eAAesQ,EAAsBrQ,UAAW,aAAc,CACjEC,IAAK,WACD,OAAOC,KAAKkS,WAEhBhS,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAesQ,EAAsBrQ,UAAW,cAAe,CAClEC,IAAK,WACD,OAAOC,KAAKmS,YAEhBjS,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAesQ,EAAsBrQ,UAAW,kBAAmB,CACtEC,IAAK,WACD,OAAOC,KAAKoS,eAEhBlS,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDgQ,EAAsBrQ,UAAU2Q,eAAiB,SAAU4B,EAAOC,GAC9D,IAAIC,EAAO,IAAIvV,WAAWqV,EAAMjV,MAAM,EAGlCoV,GAFJD,EAAKrU,IAAImU,EAAO,CAAC,EACjBrS,KAAKqS,MAAQE,EACI,IAAIxU,WAAWuU,EAAQlV,MAAM,GAC9CoV,EAAWtU,IAAIoU,EAAS,CAAC,EACzBtS,KAAKmS,WAAaK,GAMtBrC,EAAsBrQ,UAAUwR,MAAQ,WACpC,IAAK,IAAInU,EAAI,EAAGA,EAAI6C,KAAKoS,cAAchV,OAAQD,CAAC,GAC5C6C,KAAKoS,cAAcjV,GAAK,EAE5B6C,KAAKqS,MAAQhS,KAAAA,EACbL,KAAKmS,WAAa9R,KAAAA,GAOtB8P,EAAsBrQ,UAAU2R,kBAAoB,SAAUT,GAC1DhR,KAAKyS,OAAOjC,uBAA0C,MAAnBxQ,KAAKqS,MAAMrB,GAAgBhR,KAAKmS,WAAWnB,EAAK,GAMvFb,EAAsBrQ,UAAUoR,WAAa,WAIzC,IAHA,IAAIwB,EAAW,IAAI7V,WAAWmD,KAAK2S,SAAS,EAExC3B,GADJhR,KAAKqS,MAAQ,IAAIrV,WAAWgD,KAAKkS,SAAS,EAC/B,GACFU,EAAY,EAAGA,EAAY5S,KAAK2S,UAAWC,CAAS,GACzDF,EAASE,GAAa5B,EACtBA,GAAQhR,KAAK6S,YAAYD,IAAe,GAAKA,EAEjD,IAAK,IAAIzV,EAAI,EAAGA,EAAI6C,KAAKkS,UAAW/U,CAAC,GAAI,CACrC,IAAIoU,EAAOvR,KAAKmS,WAAWhV,GAChB,EAAPoU,IACAvR,KAAKqS,MAAMlV,GAAKgT,EAAsBlU,WAAWyW,EAASnB,EAAO,EAAE,EACnEmB,EAASnB,EAAO,IAAM,GAAM,GAAKA,KAI7CpB,EAAsBlU,WAAa,SAAUC,GACzC,OAAQiU,EAAsBhU,YAAoB,GAARD,IAAe,GACnDiU,EAAsBhU,YAAaD,GAAS,EAAK,KAAO,EACxDiU,EAAsBhU,YAAaD,GAAS,EAAK,KAAO,EACxDiU,EAAsBhU,YAAYD,GAAS,KAMrDiU,EAAsBrQ,UAAUuQ,iBAAmB,WAE/C,IADA,IAAI/C,EAAM,EACDnQ,EAAI,EAAGA,EAAI6C,KAAKoS,cAAchV,OAAQD,CAAC,GAC5CmQ,GAAOtN,KAAKoS,cAAcjV,GAAK6C,KAAKmS,WAAWhV,GAEnD,OAAOmQ,GAOX6C,EAAsBrQ,UAAUiQ,gBAAkB,SAAU+C,GAMxD,IALA,IAAIzL,EACA0L,EAEAC,EAAS,CAAC,EACV7V,EAAI,EACDA,EAAI6C,KAAKkS,WAAW,CAEvB,IADAlT,EAAQ,EACJiU,EAAUjT,KAAKmS,WAAWhV,GAe9B,IAdgB,IAAZ8V,GACA5L,EAAW,IACX0L,EAAW,IAGX1L,EAAW,EACX0L,EAAW,EACPC,IAAWC,IACXH,EAAOV,cAAca,EAAQ,GAC7BjU,EAAQ,IAGhBgU,EAASC,EACT9V,CAAC,GACMA,EAAI6C,KAAKkS,WAAac,IAAWhT,KAAKmS,WAAWhV,KACpDA,CAAC,GACG,EAAA,EAAE6B,GAASqI,MAIfrI,EAAQ+T,EACRD,EAAOV,cAAcY,IAAWhU,EAEhB,IAAXgU,EACLF,EAAOV,cAAc,GAAG,GAEnBpT,GAAS,GACd8T,EAAOV,cAAc,GAAG,GAGxBU,EAAOV,cAAc,GAAG,KAQpCjC,EAAsBrQ,UAAUuR,UAAY,SAAUyB,GAMlD,IALA,IAAII,EACAC,EAEAC,EAAoB,CAAC,EACrBjW,EAAI,EACDA,EAAI6C,KAAKkS,WAAW,CAEvB,IADAmB,EAAqB,EACjBJ,EAAUjT,KAAKmS,WAAWhV,GAe9B,IAdgB,IAAZ8V,GACAC,EAAiB,IACjBC,EAAiB,IAGjBD,EAAiB,EACjBC,EAAiB,EACbC,IAAsBH,IACtBH,EAAOrB,kBAAkBwB,CAAO,EAChCI,EAAqB,IAG7BD,EAAoBH,EACpB9V,CAAC,GACMA,EAAI6C,KAAKkS,WAAakB,IAAsBpT,KAAKmS,WAAWhV,KAC/DA,CAAC,GACG,EAAA,EAAEkW,GAAsBH,MAIhC,GAAIG,EAAqBF,EACrB,KAA8B,EAAvBE,CAAkB,IACrBP,EAAOrB,kBAAkB2B,CAAiB,OAGnB,IAAtBA,GACLN,EAAOrB,kBAAkB,EAAE,EAC3BzR,KAAKyS,OAAOjC,uBAAuB6C,EAAqB,EAAG,CAAC,GAEvDA,GAAsB,IAC3BP,EAAOrB,kBAAkB,EAAE,EAC3BzR,KAAKyS,OAAOjC,uBAAuB6C,EAAqB,EAAG,CAAC,IAG5DP,EAAOrB,kBAAkB,EAAE,EAC3BzR,KAAKyS,OAAOjC,uBAAuB6C,EAAqB,GAAI,CAAC,KAQzElD,EAAsBrQ,UAAUgQ,UAAY,WAKxC,IAJA,IAAIwD,EAAatT,KAAKoS,cAAchV,OAChCmW,EAAU,IAAI1W,WAAWyW,CAAU,EACnCnC,EAAa,EACb9J,EAAW,EACNmM,EAAI,EAAGA,EAAIF,EAAYE,CAAC,GAAI,CACjC,IAAIC,EAAOzT,KAAKoS,cAAcoB,GAC9B,GAAa,IAATC,EAAY,CAGZ,IAFA,IAAIC,EAAMvC,CAAU,GAChBwC,EAAO,EACE,EAAND,GAAW1T,KAAKoS,cAAcmB,EAAQI,EAAOjP,KAAK6K,OAAOmE,EAAM,GAAK,CAAC,IAAMD,GAC9EF,EAAQG,GAAOH,EAAQI,GACvBD,EAAMC,EAGVtM,EADAkM,EAAQG,GAAOF,GAIvB,KAAOrC,EAAa,GAChBoC,EAAQpC,CAAU,IACb9J,EAAW,EAAK,EAAEA,EAAW,EAEtCrH,KAAKkS,UAAYxN,KAAKiD,IAAIN,EAAW,EAAGrH,KAAK4T,YAAY,EAKzD,IAJA,IACIC,EADa1C,EAEb2C,EAAQ,IAAIjX,WAAW,EAAIsU,EAAa,CAAC,EACzC4C,EAAS,IAAIlX,WAAW,EAAIsU,EAAa,CAAC,EACrChU,EAAI,EAAGA,EAAIgU,EAAYhU,CAAC,GAAI,CACjC,IAAI6W,EAAOT,EAAQpW,GACf8W,EAAS,EAAI9W,EACjB2W,EAAMG,GAAUD,EAChBF,EAAe,EAATG,GAAc,CAAC,EACrBF,EAAO5W,GAAM6C,KAAKoS,cAAc4B,IAAS,EACzCT,EAAQpW,GAAKA,EAEjB6C,KAAKkU,qBAAqBX,EAASpC,EAAY4C,EAAQF,EAAYC,CAAK,EACxE9T,KAAKmU,YAAYL,CAAK,GAE1B3D,EAAsBrQ,UAAUoU,qBAAuB,SAAUX,EAASpC,EAAY4C,EAAQF,EAAYC,GACtG,EAAG,CAMC,IALA,IAAIM,EAAQb,EAAQ,GAChBc,EAAOd,EAAQ,EAAEpC,GACjBmD,EAAUP,EAAOM,GACjBV,EAAO,EACPY,EAAO,EACJA,EAAOpD,GACNoD,EAAO,EAAIpD,GAAc4C,EAAOR,EAAQgB,IAASR,EAAOR,EAAQgB,EAAO,KACvEA,CAAI,GAERhB,EAAQI,GAAQJ,EAAQgB,GAExBA,EAAc,GADdZ,EAAOY,GACW,EAEtB,KAAuB,GAAfA,EAAOZ,IAAaI,EAAOR,EAAQI,EAAOjP,KAAK6K,OAAOgF,EAAO,GAAK,CAAC,IAAMD,GAC7Ef,EAAQgB,GAAQhB,EAAQI,GAE5BJ,EAAQgB,GAAQF,EAChB,IAAIG,EAASjB,EAAQ,GAIjBkB,GAFJX,EAAM,GAAIO,EADHR,CAAU,KACCO,EAClBN,EAAM,EAAIO,EAAO,GAAKG,EACP9P,KAAKC,IAAoB,IAAhBoP,EAAOK,GAAgC,IAAjBL,EAAOS,EAAc,GAKnE,IAJAT,EAAOM,GAAQC,EAAUP,EAAOK,GAASL,EAAOS,GAAUC,EAAW,EACrEd,EAAO,EACPY,EAAO,EAEAA,EAAOpD,GACNoD,EAAO,EAAIpD,GAAc4C,EAAOR,EAAQgB,IAASR,EAAOR,EAAQgB,EAAO,KACvEA,CAAI,GAERhB,EAAQI,GAAQJ,EAAQgB,GAExBA,EAAc,GADdZ,EAAOY,GACW,EAEtB,KAAuB,GAAfA,EAAOZ,IAAaI,EAAOR,EAAQI,EAAOjP,KAAK6K,OAAOgF,EAAO,GAAK,CAAC,IAAMD,GAC7Ef,EAAQgB,GAAQhB,EAAQI,SAE5BJ,EAAQgB,GAAQF,EACE,EAAblD,IAEbhB,EAAsBrQ,UAAUqU,YAAc,SAAUL,GACpD9T,KAAKmS,WAAa,IAAIpU,WAAWiC,KAAKoS,cAAchV,MAAM,EAI1D,IAHA,IAAIsX,EAAWhQ,KAAK6K,MAAMuE,EAAM1W,OAAS,CAAC,EACtCuX,EAAWjQ,KAAK6K,OAAOmF,EAAW,GAAK,CAAC,EACxCE,EAAW,EACNzX,EAAI,EAAGA,EAAI6C,KAAK2S,UAAWxV,CAAC,GACjC6C,KAAK6S,YAAY1V,GAAK,EAG1B,GAAiB,KADjByX,EAAW5U,KAAK6U,2BAA2Bf,EAAOc,EAAUF,CAAQ,GACpE,CAGA,IAAII,EAAqB9U,KAAK2S,UAAY,EAC1C,EAAG,CACC,KAAkD,IAA3C3S,KAAK6S,YAAY,EAAEiC,KAG1B,KACI9U,KAAK6S,YAAYiC,EAAmB,GACpC9U,KAAK6S,YAAY,EAAEiC,EAAmB,GAEtB,GADhBF,GAAa,GAAM5U,KAAK2S,UAAY,EAAImC,IACnBA,EAAqB9U,KAAK2S,UAAY,WAC/C,EAAXiC,GACT5U,KAAK+U,aAAajB,EAAOc,EAAUD,CAAQ,IAE/CxE,EAAsBrQ,UAAUiV,aAAe,SAAUjB,EAAOc,EAAUD,GACtE3U,KAAK6S,YAAY7S,KAAK2S,UAAY,IAAMiC,EACxC5U,KAAK6S,YAAY7S,KAAK2S,UAAY,IAAMiC,EAExC,IADA,IAAII,EAAU,EAAIL,EACTpD,EAAOvR,KAAK2S,UAAoB,IAATpB,EAAYA,CAAI,GAE5C,IADA,IAAIiC,EAAIxT,KAAK6S,YAAYtB,EAAO,GACrB,EAAJiC,GAAO,CACV,IAAIyB,EAAW,EAAInB,EAAMkB,CAAO,IACJ,CAAC,IAAzBlB,EAAiB,EAAXmB,KACNjV,KAAKmS,WAAW2B,EAAMmB,IAAa1D,EACnCiC,CAAC,MAKjBrD,EAAsBrQ,UAAU+U,2BAA6B,SAAUf,EAAOc,EAAUF,GACpF,IAAIpC,EAAU,IAAIzV,WAAW6X,CAAQ,EACrCpC,EAAQoC,EAAW,GAAK,EACxB,IAAK,IAAIvX,EAAIuX,EAAW,EAAQ,GAALvX,EAAQA,CAAC,GAAI,CACpC,IAUQ+X,EAVJC,EAAa,EAAIhY,EAAI,EACC,CAAC,IAAvB2W,EAAMqB,KAEFD,EADY5C,EAAQnV,GAAK,GACb6C,KAAK2S,YACjBuC,EAAYlV,KAAK2S,UACjBiC,CAAQ,IAEZtC,EAAQwB,EAAMqB,EAAa,IAAM7C,EAAQwB,EAAMqB,IAAeD,IAG1DA,EAAY5C,EAAQnV,GACxB6C,KAAK6S,YAAYqC,EAAY,EAAE,GAC/BlV,KAAKmS,WAAW2B,EAAMqB,EAAa,IAAM7C,EAAQnV,IAGzD,OAAOyX,GAEXzE,EAAsBhU,YAAc,CAAC,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IACvFgU,EAAsB3Q,qBAAuB,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,QA1V5G2Q,EA2VOA,EAnVP,SAASA,EAAsBsC,EAAQ2C,EAAcC,EAAU1C,GAC3D3S,KAAKyS,OAASA,EACdzS,KAAK4T,aAAeyB,EACpBrV,KAAK2S,UAAYA,EACjB3S,KAAKoS,cAAgB,IAAIzV,YAAYyY,CAAY,EACjDpV,KAAK6S,YAAc,IAAIhW,WAAW8V,CAAS,EAgW/C5H,EAAmBC,eAAiB,SAAUsK,EAAUtX,EAAQmI,EAAQ/I,GAMpE,IALA,IAAIZ,EAAO,IAAIC,YAAY,CAAC,EAExB8Y,GADJ/Y,EAAK,GAAK8Y,EACU9Y,EAAK,IACrBgZ,EAAKhZ,EAAK,GAAqB,MAAhB+Y,EACfE,EAAKjZ,EAAK,GAAK+Y,GAAiBxK,EAAmB2K,kBACvC,EAATtY,GAAY,CACf,IAAIuY,EAAQjR,KAAKC,IAAIvH,EAAQ2N,EAAmB6K,sBAAsB,EAEtE,IADAxY,GAAUuY,EACQ,GAAX,EAAEA,GAELF,GADAD,GAAWhZ,EAAK,GAAyB,IAAnBwB,EAAOmI,CAAM,IAGvCqP,GAAMzK,EAAmB8K,aACzBJ,GAAM1K,EAAmB8K,aAG7B,OADiBJ,GAAM1K,EAAmB2K,kBAAqBF,GAGnEzK,EAAmB2K,kBAAoB,GACvC3K,EAAmB8K,aAAe,MAClC9K,EAAmB6K,uBAAyB,SAjC5C7K,EAkCOA,EAjCP,SAASA,KCr7BT+K,EAAwBC,KAAO,WAM3B,IALA,IAGAzD,EAAU,IAAIvU,WAAW,GAAG,EAC5B1B,EAAQ,EACDA,EAAQ,KACXiW,EAAQjW,CAAK,IAAM,EAEvB,KAAOA,EAAQ,KACXiW,EAAQjW,CAAK,IAAM,EAEvB,KAAOA,EAAQ,KACXiW,EAAQjW,CAAK,IAAM,EAEvB,KAAOA,EAAQ,KACXiW,EAAQjW,CAAK,IAAM,EAMvB,IAJAyZ,EAAwBE,aAAe,IAAIF,EAAwBxD,CAAO,EAE1EA,EAAU,IAAIvU,WAAW,EAAE,EAC3B1B,EAAQ,EACDA,EAAQ,IACXiW,EAAQjW,CAAK,IAAM,EAEvByZ,EAAwBG,eAAiB,IAAIH,EAAwBxD,CAAO,GAUhFwD,EAAwBhW,UAAUoW,YAAc,SAAUC,EAASzD,EAAUJ,GAIzE,IAHA,IAAItB,EAAO,EACPoF,EAAW,IAENjZ,EAAI,EAAGA,EAAImV,EAAQlV,OAAQD,CAAC,GAAI,CACrC,IAAI8G,EAAWqO,EAAQnV,GACR,EAAX8G,GACAkS,EAAQlS,EAAS,GAGzB,IAAK,IAAIsN,EAAO,EAAGA,GAAQuE,EAAwBO,WAAY9E,CAAI,GAC/DmB,EAASnB,GAAQP,EACjBA,GAAQmF,EAAQ5E,IAAU,GAAKA,EACnB,IAARA,IAGA6E,IADiB,OAAPpF,IADmB,OAAjB0B,EAASnB,KAES,GAAKA,GAK3C,MAAO,CAAEP,KAAQA,EAAMoF,SAAYA,IAWvCN,EAAwBhW,UAAUwW,aAAe,SAAUH,EAASzD,EAAUJ,EAAStB,EAAMoF,GAIzF,IAHA,IAAIG,EAAO,IAAIvZ,WAAWoZ,CAAQ,EAC9BI,EAAU,IAELjF,EAAOuE,EAAwBO,WAAoB,IAAR9E,EAAYA,CAAI,GAIhE,IAHA,IAAI/G,EAAa,OAAPwG,EAGD7T,EADU,QADnB6T,GAAQmF,EAAQ5E,IAAU,GAAKA,GAEXpU,EAAIqN,EAAKrN,GALjB,IAMRoZ,EAAKva,EAAMC,WAAWkB,CAAC,GAAKnB,EAAMe,yBAA0B,CAACyZ,GAAW,EAAKjF,CAAI,EACjFiF,GAAW,GAAMjF,EAAO,EAGhC,IAASpU,EAAI,EAAGA,EAAImV,EAAQlV,OAAQD,CAAC,GAAI,CACjCoU,EAAOe,EAAQnV,GACnB,GAAY,GAARoU,EAAJ,CAGAP,EAAO0B,EAASnB,GAChB,IAAIkF,EAAUza,EAAMC,WAAW+U,CAAI,EACnC,GAAIO,GAAQ,EACR,KACIgF,EAAKE,GAAWza,EAAMe,yBAA0BI,GAAK,EAAKoU,CAAI,GAC9DkF,GAAW,GAAKlF,GACD,WAMnB,IAHA,IACImF,EAAU,IAAgB,IAAVC,EADNJ,EAAe,IAAVE,KAEnBE,EAAU,EAAEA,GAAW,GAEnBJ,EAAKI,EAAWF,GAAW,GAAMza,EAAMe,yBAA0BI,GAAK,EAAKoU,CAAI,GAC/EkF,GAAW,GAAKlF,GACDmF,IAEvBhE,EAASnB,GAAQP,GAAQ,GAAM,GAAKO,IAExC,OAAOgF,GAMXT,EAAwBhW,UAAUgQ,UAAY,SAAUwC,GAEpD,IAAI6D,EAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAExDzD,EAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzDwD,EAAclW,KAAKkW,YAAYC,EAASzD,EAAUJ,CAAO,EAC7DtS,KAAK4W,OAAS5W,KAAKsW,aAAaH,EAASzD,EAAUJ,EAAS4D,EAAYlF,KAAMkF,EAAYE,QAAQ,GAOtGN,EAAwBhW,UAAU+W,aAAe,SAAUrY,GACvD,IAOQsY,EASAC,EACAC,EAWAzF,EA1BR,OAAuC,IAAlCwF,EAAYvY,EAAMyY,SAAS,CAAC,GACY,IAApCD,EAAShX,KAAK4W,OAAOG,KACtBvY,EAAM0Y,SAAmB,GAATF,GACTA,GAAU,IAEjBF,EAAU,EAAEE,GAAU,GAEkB,IAAvCD,EAAYvY,EAAMyY,SADD,GAATD,CACyB,IAClCA,EAAShX,KAAK4W,OAAOE,EAAWC,GAAa,GAC7CvY,EAAM0Y,SAAmB,GAATF,GACTA,GAAU,IAGbzF,EAAO/S,EAAM2Y,cACjBJ,EAAYvY,EAAMyY,SAAS1F,CAAI,GAEjB,IAATyF,EADIhX,KAAK4W,OAAOE,EAAWC,GAAa,MACxBxF,GACjB/S,EAAM0Y,SAAmB,GAATF,GACTA,GAAU,GAGV,CAAC,KAKZzF,EAAO/S,EAAM2Y,cACjBJ,EAAYvY,EAAMyY,SAAS1F,CAAI,EAEjB,IADdyF,EAAShX,KAAK4W,OAAOG,MACQ,GAATC,IAAgBzF,GAChC/S,EAAM0Y,SAAmB,GAATF,GACTA,GAAU,GAGV,CAAC,IAIpBpX,OAAOC,eAAeiW,EAAyB,aAAc,CAIzD/V,IAAK,WACD,OAAOC,KAAKgW,cAEhB9V,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDP,OAAOC,eAAeiW,EAAyB,eAAgB,CAI3D/V,IAAK,WACD,OAAOC,KAAKiW,gBAEhB/V,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAID2V,EAAwBO,WAAa,OA/LrCP,EAgMOA,EA/LP,SAASA,EAAwBxD,GAC7BtS,KAAK8P,UAAUwC,CAAO,ECW1BvH,EAAmBqM,eAAiB,SAAU9B,EAAUtX,EAAQmI,EAAQ/I,GAIpE,IAHA,IACIoY,EAAoB,MADLF,EAEfG,EAFeH,GAEMtV,KAAKqX,wBACd,EAATja,GAAY,CACf,IAAIuY,EAAQjR,KAAKC,IAAIvH,EAAQ4C,KAAKsX,4BAA4B,EAE9D,IADAla,GAAUuY,EACQ,GAAX,EAAEA,GAELF,GADAD,GAA8B,IAAnBxX,EAAOmI,CAAM,IAG5BqP,GAAMxV,KAAKuX,kBACX9B,GAAMzV,KAAKuX,kBAEOvX,KAAKqX,yBAU/BtM,EAAmByM,iBAAmB,SAAUxZ,EAAQmI,EAAQ/I,GAG5D,OADA2N,EAAmBqM,eADN,EAC6BpZ,EAAQmI,EAAQ/I,CAAM,EADnD,GAOjB2N,EAAmBsM,wBAA0B,GAI7CtM,EAAmBwM,kBAAoB,MAIvCxM,EAAmBuM,6BAA+B,KAnDtD,IAAIvM,EAoDOA,EAnDP,SAASA,KCmHTnL,OAAOC,eAAeyJ,EAAuBxJ,UAAW,UAAW,CAC/DC,IAAK,WACD,OAAOC,KAAKyX,SAEhBvZ,IAAK,SAAUhC,GACX8D,KAAKyX,QAAUvb,GAEnBgE,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAUDmJ,EAAuBxJ,UAAUmX,SAAW,SAAUjY,GAClD,GAAIA,EAAQ,EACR,MAAM,IAAIoC,aAAa,QAAS,uCAAuC,EAE3E,GAAY,GAARpC,EACA,MAAM,IAAIoC,aAAa,QAAS,6BAA6B,EASjE,OALIpB,KAAK0X,cAAgB1Y,GACrBgB,KAAK2X,aAIL3X,KAAK0X,cAAgB1Y,EACd,CAAC,EAIChD,EAAMY,wBAAwBoD,KAAK4X,QADlC,EAAE,YAAc5Y,EACmC,GAIrEsK,EAAuBxJ,UAAU6X,WAAa,WAC1C,IAAIva,EAAS,GAAK4C,KAAK0X,eAAiB,IACL,IAAP,EAArB1X,KAAK0X,eAA4B,EAAI,GAC5C,GAAe,GAAXta,EAKJ,IADA,IAAIya,EAAY7X,KAAK8X,aAAahQ,KAAK9H,KAAK+X,YAAa,EAAG3a,CAAM,EACzDD,EAAI,EAAGA,EAAI0a,EAAW1a,CAAC,GAC5B6C,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,QAC7C5b,EAAMc,wBAAwBkD,KAAK+X,YAAY5a,IAAM6C,KAAK0X,aAAc,CAAC,EAC9E1X,KAAK0X,eAAiB,GAQ9BpO,EAAuBxJ,UAAUoX,SAAW,SAAUlY,GAClD,GAAIA,EAAQ,EACR,MAAM,IAAIoC,aAAa,QAAS,uCAAuC,EAE7D,IAAVpC,IAGAA,GAASgB,KAAK0X,eACd1Y,GAASgB,KAAK0X,cACd1X,KAAK0X,cAAgB,GACrB1X,KAAK4X,QAAU,GAEX5Y,IAEAgB,KAAK8X,aAAarW,UAAazC,GAAS,EAG5B,GAFZA,GAAS,MAGLgB,KAAK2X,aACL3X,KAAK0X,eAAiB1Y,EACtBgB,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,UAAY5Y,CAAK,KAK3EgB,KAAK0X,eAAiB1Y,EACtBgB,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,UAAY5Y,CAAK,KAG3EY,OAAOC,eAAeyJ,EAAuBxJ,UAAW,gBAAiB,CACrEC,IAAK,WACD,OAAOC,KAAK0X,eAEhBxX,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EAIDmJ,EAAuBxJ,UAAUkY,eAAiB,WAG9C,IAAI9S,EAASlF,KAAKiY,YAElB,GAAe,CAAC,IAAZ/S,EACA,MAAM,IAAI9D,aAAa,uCAAuC,EAElE,GAAI8D,EAAS,IAAO,EAChB,MAAM,IAAI9D,aAAa,yBAAyB,EAEpD,UAAK8D,EAASlF,KAAKkY,wBACf,MAAM,IAAI9W,aAAa,iCAAiC,EAG5D,GADApB,KAAKmY,YAAczT,KAAK0T,IAAI,EAAkD,IAA7ClT,EAASlF,KAAKqY,uBAAyB,GAAO,EACxD,MAAnBrY,KAAKmY,YACL,MAAM,IAAI/W,aAAa,yDAAyD,EAEpF,IAAK8D,EAASlF,KAAKsY,yBAA2B,GAAM,EAEhD,MAAM,IAAIlX,aAAa,mDAAmD,GASlFkI,EAAuBxJ,UAAUmY,UAAY,WACzC,IAAIvU,EAAU1D,KAAKuY,SAAS,CAAC,GAAK,EAElC,OADA7U,GAAU1D,KAAKuY,SAAS,CAAC,GAU7BjP,EAAuBxJ,UAAUyY,SAAW,SAAUvZ,GAClD,IAAI0E,EAAS1D,KAAKiX,SAASjY,CAAK,EAChC,MAAe,CAAC,IAAZ0E,EACO,CAAC,GAEZ1D,KAAK0X,eAAiB1Y,EACtBgB,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,UAAY5Y,CAAK,EAC5D0E,IAMX4F,EAAuBxJ,UAAU0Y,kBAAoB,WACjD,GAAI,CAACxY,KAAKyY,mBACN,MAAO,CAAA,EAEX,IAAIC,EAAc1Y,KAAKuY,SAAS,CAAC,EACjC,GAAoB,CAAC,IAAjBG,EACA,MAAO,CAAA,EAEX,IAAIC,EAAY3Y,KAAKuY,SAAS,CAAC,EAC/B,GAAkB,CAAC,IAAfI,EACA,MAAO,CAAA,EAIX,OAFA3Y,KAAKyY,mBAAsC,IAAhBC,EAEnBC,GACJ,KAAK,EAED3Y,KAAK4Y,sBAAwB,CAAA,EAC7B5Y,KAAK6Y,iBACL,IAAI5U,EAAWjE,KAAK8Y,oBAEpB,GAAI7U,KAAiC,MADdjE,KAAK8Y,qBAExB,MAAM,IAAI1X,aAAa,qBAAqB,EAEhD,GAAe,MAAX6C,EACA,MAAM,IAAI7C,aAAa,uDAAuD,EAElFpB,KAAK+Y,wBAA0B9U,EAC/BjE,KAAKgZ,mBAAqB,KAC1BhZ,KAAKiZ,qBAAuB,KAC5B,MACJ,KAAK,EAEDjZ,KAAK4Y,sBAAwB,CAAA,EAC7B5Y,KAAK+Y,wBAA0B,CAAC,EAChC/Y,KAAKgZ,mBAAqBlD,EAAwBoD,WAClDlZ,KAAKiZ,qBAAuBnD,EAAwBqD,aACpD,MACJ,KAAK,EAEDnZ,KAAK4Y,sBAAwB,CAAA,EAC7B5Y,KAAK+Y,wBAA0B,CAAC,EAC5BK,EAAQpZ,KAAKqZ,oBAAoBrZ,KAAKgZ,mBAAoBhZ,KAAKiZ,oBAAoB,EACvFjZ,KAAKgZ,mBAAqBI,EAAMF,WAChClZ,KAAKiZ,qBAAuBG,EAAMD,aAClC,MACJ,QACI,MAAM,IAAI/X,aAAa,mBAAmB,EAElD,MAAO,CAAA,GAKXkI,EAAuBxJ,UAAU+Y,eAAiB,WAC9C7Y,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,WAAkC,EAArB5X,KAAK0X,cAAkB,EACtF1X,KAAK0X,eAAiB,CAAA,GAQ1BpO,EAAuBxJ,UAAUgZ,kBAAoB,WACjD,IAAIpV,EAAU1D,KAAKuY,SAAS,CAAE,EAE9B,OADA7U,GAAU1D,KAAKuY,SAAS,CAAC,GAAK,GAQlCjP,EAAuBxJ,UAAUuZ,oBAAsB,SAAUH,EAAYC,GACzE,IAAIG,EAAc,EACdC,EAAgBvZ,KAAKuY,SAAS,CAAC,EAC/BiB,EAAkBxZ,KAAKuY,SAAS,CAAC,EACjCkB,EAAoBzZ,KAAKuY,SAAS,CAAC,EACvC,GAAIgB,EAAgB,GAAKC,EAAkB,GAAKC,EAAoB,EAChE,MAAM,IAAIrY,aAAa,8BAA8B,EASzD,IALA,IAAIsY,GAFJH,GAAiB,MACjBC,GAAmB,GAEfG,EAA0B,IAAI5b,WAAW2b,CAA0B,EACnEE,EAAwB,IAAI7b,WAAW,EAAE,EAEzC8b,GADJJ,GAAqB,EACF,GACZI,EAAeJ,GAAmB,CACrC,IAAInM,EAAMtN,KAAKuY,SAAS,CAAC,EACzB,GAAIjL,EAAM,EACN,MAAM,IAAIlM,aAAa,8BAA8B,EAEzDwY,EAAsB5Z,KAAK8Z,0BAA0BD,CAAY,KAAOvM,EAI5E,IAFA,IAAIyM,EAAsB,IAAIjE,EAAwB8D,CAAqB,EAC3EC,EAAe,IACN,CAIL,IAHA,IAAI7C,EAAS,KAAA,EACTgD,EAAa,CAAA,EACjBhD,EAAS+C,EAAoBlD,aAAa7W,IAAI,EACpB,IAAT,CAAA,GAATgX,IAAqB,CAEzB,GADA2C,EAAwBE,CAAY,IAAMP,EAActC,EACpD6C,IAAiBH,EAA4B,CAC7CM,EAAa,CAAA,EACb,MAEJhD,EAAS+C,EAAoBlD,aAAa7W,IAAI,EAElD,GAAIga,EACA,MAEJ,GAAIhD,EAAS,EACT,MAAM,IAAI5V,aAAa,8BAA8B,EAEzD,GAAc,IAAV4V,EACAsC,EAAc,OAEb,GAAqB,IAAjBO,EACL,MAAM,IAAIzY,aAAa,8BAA8B,EAEzD,IAAI6Y,EAAcjD,EAAS,GACvBzF,EAAOjI,EAAuB4Q,gCAAgCD,GAC9Djb,EAAQgB,KAAKuY,SAAShH,CAAI,EAC9B,GAAIvS,EAAQ,EACR,MAAM,IAAIoC,aAAa,8BAA8B,EAGzD,GAA2BsY,EAAvBG,GADJ7a,GAASsK,EAAuB6Q,oCAAoCF,IAEhE,MAAM,IAAI7Y,aAAa,8BAA8B,EAEzD,KAAiB,EAAVpC,CAAK,IACR2a,EAAwBE,CAAY,IAAMP,EAE9C,GAAIO,IAAiBH,EACjB,MAGR,IAAIU,EAAY,IAAIrc,WAAWwb,CAAa,EAQ5C,OAPAa,EAAUlc,IAAIyb,EAAwB1b,SAAS,EAAGsb,CAAa,EAAG,CAAC,EAGnEL,EAAa,IAAIpD,EAAwBsE,CAAS,EAClDA,EAAYT,EAAwB7Y,MAAMyY,EAAeA,EAAgBC,CAAe,EAGjF,CAAEN,WAAcA,EAAYC,aADpB,IAAIrD,EAAwBsE,CAAS,IAOxD9Q,EAAuBxJ,UAAUua,YAAc,WAO3C,IANA,IAAIC,EAAOta,KAAKua,qBAAuBva,KAAKwa,YAAcxa,KAAKya,kBAC3DC,EAAW,CAAA,EAKRJ,GAAQta,KAAK2a,yBAAyB,CAIzC,IAHA,IAAI3D,EAAS,KAAA,EACbA,EAAShX,KAAKgZ,mBAAmBnC,aAAa7W,IAAI,EAEpB,IAAX,CAAA,IAAX,IAAyB,CAI7B,IAHUA,KAAKwa,YAAc,GAAKxa,KAAKua,oBACvCva,KAAK4a,aAAa5a,KAAKwa,WAAW,GAAKxa,KAAKua,qBAAuBvD,EACnE0D,EAAW,CAAA,EACP,EAAEJ,EAAOta,KAAK2a,wBACd,MAAO,CAAA,EAGX3D,EAAShX,KAAKgZ,mBAAmBnC,aAAa7W,IAAI,EAEtD,GAAIgX,EAAShX,KAAK6a,+BAAgC,CAC9C,GAAI7D,EAAShX,KAAK8a,sBACd,MAAM,IAAI1Z,aAAa,eAAe,EAE1C,IAAI2Z,EAAcL,EAAW,EAAI,EAGjC,OAFA1a,KAAKgb,kBAAoBhb,KAAKwY,oBAEvB,CAAA,EAACuC,GADW/a,KAAsB,kBAAI,EAAI,IAGrD,GAAIgX,EAAShX,KAAKib,+BACd,MAAM,IAAI7Z,aAAa,6BAA6B,EAExD,IAAI8Z,EAAgB5R,EAAuB6R,+BAA+BnE,EACtEhX,KAAK6a,gCACLO,EAAmB9R,EAAuB+R,oCAAoCrE,EAC9EhX,KAAK6a,gCACT,GAAuB,EAAnBO,EAAsB,CAEtB,IAAIE,EADQtb,KAAKuY,SAAS6C,CAAgB,GAC9B,EACR,MAAM,IAAIha,aAAa,aAAa,EAExC8Z,GAAiBI,EAIrB,IADAtE,EAAShX,KAAKiZ,qBAAqBpC,aAAa7W,IAAI,GACvC,GAAKgX,EAAS1N,EAAuBiS,iCAAiCne,OAC/E,MAAM,IAAIgE,aAAa,sBAAsB,EAEjD,IAGQka,EAHJE,EAAkBlS,EAAuBiS,iCAAiCvE,GAE9E,GAAuB,GAAnBoE,EADe9R,EAAuBmS,sCAAsCzE,IACtD,CAEtB,IAAIsE,EADQtb,KAAKuY,SAAS6C,CAAgB,GAC9B,EACR,MAAM,IAAIha,aAAa,aAAa,EAExCoa,GAAmBF,EAGvB,IAAK,IAAIne,EAAI,EAAGA,EAAI+d,EAAe/d,CAAC,GAChC6C,KAAK4a,aAAa5a,KAAKwa,YAAcxa,KAAKua,qBACtCva,KAAK4a,cAAc5a,KAAKwa,YAAcgB,GAAmBxb,KAAKua,qBAClEva,KAAKwa,WAAW,GAChBF,CAAI,GAERI,EAAW,CAAA,EAEf,OAAOA,GASXpR,EAAuBxJ,UAAUgI,KAAO,SAAU9J,EAAQmI,EAAQ/I,GAC9D,GAAc,MAAVY,EACA,MAAM,IAAIoD,aAAa,QAAQ,EAEnC,GAAI+E,EAAS,GAAKA,EAASnI,EAAOZ,OAAS,EACvC,MAAM,IAAIgE,aAAa,SAAU,6CAA6C,EAElF,GAAIhE,EAAS,GAAKA,EAASY,EAAOZ,OAAS+I,EACvC,MAAM,IAAI/E,aAAa,SAAU,oBAAoB,EAGzD,IADA,IAAIsa,EAAgBte,EACJ,EAATA,GAEH,GAAI4C,KAAKya,iBAAmBza,KAAKwa,YAAa,CAE1C,IAAImB,EAAmB3b,KAAKya,iBAAmBza,KAAKua,oBAGhD1c,EAAa6G,KAAKC,IAAI3E,KAAKua,oBAAsBoB,EAAkB3b,KAAKwa,YAAcxa,KAAKya,kBAE/F5c,EAAa6G,KAAKC,IAAI9G,EAAYT,CAAM,EAKxCpB,EAAMwB,UAAUwC,KAAK4a,aAAce,EAAiB3d,EAAQmI,EAAQtI,CAAU,EAE9EmC,KAAKya,kBAAoB5c,EACzBsI,GAAUtI,EACVT,GAAUS,MAET,CACD,GAAI,CAACmC,KAAKgb,kBACN,MAEAY,EAAgB5b,KAAKwa,YACzB,GAAKxa,KAAK4Y,sBAMN,GAAqC,IAAjC5Y,KAAK+Y,yBAGL,GADA/Y,KAAKgb,kBAAoBhb,KAAKwY,oBAC1B,CAAExY,KAAsB,kBACxB,UAGH,CAED,IAAI2b,EAAmB3b,KAAKwa,YAAcxa,KAAKua,oBAC3CsB,EAAanX,KAAKC,IAAI3E,KAAK+Y,wBAAyB/Y,KAAKua,oBAAsBoB,CAAe,EAC9FjB,EAAW1a,KAAK8b,gBAAgB9b,KAAK4a,aAAce,EAAiBE,CAAU,EAClF,GAAIA,IAAenB,EACf,MAAM,IAAItZ,aAAa,4BAA4B,EAEvDpB,KAAK+Y,yBAA2B2B,EAChC1a,KAAKwa,aAAeE,OArBxB,GAAI,CAAC1a,KAAKqa,cACN,MAuBJuB,EAAgB5b,KAAKwa,eACjBuB,EAASH,EAAgB5b,KAAKua,sBAC9B/P,EAAOxK,KAAKwa,YAAcxa,KAAKua,qBAE/Bva,KAAKgL,eAAehL,KAAK4a,aAAcmB,EAAOvR,EAAMuR,CAAK,GAGzD/b,KAAKgL,eAAehL,KAAK4a,aAAcmB,EAAO/b,KAAKua,oBAAsBwB,CAAK,EACpE,EAANvR,GACAxK,KAAKgL,eAAehL,KAAK4a,aAAc,EAAGpQ,CAAG,IAMjE,GAAI,CAACxK,KAAKgb,mBAAqB,CAAChb,KAAKgc,gBAAkB,CAAChc,KAAKic,SAAU,CAInE,GAHAjc,KAAK6Y,iBACU7Y,KAAKkc,cAEHlc,KAAKmc,UAClB,MAAM,IAAI/a,aAAa,wBAAwB,EAEnDpB,KAAKgc,eAAiB,CAAA,EAE1B,OAAON,EAAgBte,GAS3BkM,EAAuBxJ,UAAUgc,gBAAkB,SAAU9d,EAAQmI,EAAQ/I,GACzE,GAAc,MAAVY,EACA,MAAM,IAAIoD,aAAa,QAAQ,EAEnC,GAAI+E,EAAS,GAAKA,EAASnI,EAAOZ,OAAS,EACvC,MAAM,IAAIgE,aAAa,+EAA+E,EAE1G,GAAIhE,EAAS,EACT,MAAM,IAAIgE,aAAa,6CAA6C,EAExE,GAAIhE,EAASY,EAAOZ,OAAS+I,EACzB,MAAM,IAAI/E,aAAa,gCAAgC,EAE3D,GAAiC,IAAP,EAArBpB,KAAK0X,eACN,MAAM,IAAItW,aAAa,8CAA8C,EAEzE,GAAe,IAAXhE,EACA,OAAO,EAGX,IADA,IAAIsG,EAAS,EACe,EAArB1D,KAAK0X,eAA8B,EAATta,GAC7BY,EAAOmI,CAAM,IAAOnG,KAAY,QAChCA,KAAK0X,eAAiB,EACtB1X,KAAK4X,QAAU5b,EAAMc,wBAAwBkD,KAAK4X,UAAY,CAAC,EAC/Dxa,CAAM,GACNsG,CAAM,GAMV,OAJa,EAATtG,IAEAsG,GAAU1D,KAAK8X,aAAahQ,KAAK9J,EAAQmI,EAAQ/I,CAAM,GAEpDsG,GAQX4F,EAAuBxJ,UAAUoc,UAAY,WACzC,IAAIxY,EAAS1D,KAAKuY,SAAS,CAAC,GAAK,GAIjC,OAHA7U,GAAU1D,KAAKuY,SAAS,CAAC,GAAK,IACpBvY,KAAKuY,SAAS,CAAC,GAAK,EACpBvY,KAAKuY,SAAS,CAAC,GAU7BjP,EAAuBxJ,UAAUkL,eAAiB,SAAUhN,EAAQmI,EAAQ/I,GACxE2N,EAAmBqM,eAAepX,KAAKmc,UAAWne,EAAQmI,EAAQ/I,CAAM,GAE5EkM,EAAuB8S,iBAAmB,IAAIre,WAAW,CAAC,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAG,EAI/GuL,EAAuB6Q,oCAAsC,CAAC,EAAG,EAAG,IAIpE7Q,EAAuB4Q,gCAAkC,CAAC,EAAG,EAAG,GAIhE5Q,EAAuB6R,+BAAiC,CACpD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACrD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,KAKzD7R,EAAuB+R,oCAAsC,CACzD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAKxC/R,EAAuBiS,iCAAmC,CACtD,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,IACtD,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAClD,KAAM,MAAO,MAAO,OAKxBjS,EAAuBmS,sCAAwC,CAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAC9B,GAAI,GAAI,GAAI,QA9qBhBnS,EAgrBOA,EA/qBP,SAASA,EAAuBjI,EAAQgb,GAqGpC,GAjGArc,KAAK8Z,0BAA4B,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IAIhG9Z,KAAKkY,uBAAyB,KAI9BlY,KAAKqY,qBAAuB,MAI5BrY,KAAKsc,wBAA0B,GAI/Btc,KAAKsY,uBAAyB,GAI9BtY,KAAKuc,wBAA0B,IAI/Bvc,KAAKua,oBAAsB,MAI3Bva,KAAK2a,wBAA0B,IAI/B3a,KAAK8a,sBAAwB,IAI7B9a,KAAK6a,+BAAiC,IAItC7a,KAAKib,+BAAiC,IAItCjb,KAAKwc,iCAAmC,GAKxCxc,KAAKmc,UAAY,EAIjBnc,KAAKyX,QAAU,EAIfzX,KAAK0X,cAAgB,EAIrB1X,KAAK+X,YAAc,IAAIha,WAAW,CAAC,EAInCiC,KAAK4a,aAAe,IAAI7c,WAAWiC,KAAKua,mBAAmB,EAI3Dva,KAAKic,SAAW,CAAA,EAIhBjc,KAAKmY,YAAc,EAKnBnY,KAAKya,iBAAmB,EAKxBza,KAAKwa,YAAc,EAKnBxa,KAAKyY,mBAAqB,CAAA,EAI1BzY,KAAKgb,kBAAoB,CAAA,EAIzBhb,KAAKgc,eAAiB,CAAA,EACR,MAAV3a,EACA,MAAM,IAAID,aAAa,QAAQ,EAEnC,GAAsB,IAAlBC,EAAOjE,OACP,MAAM,IAAIgE,aAAa,kCAAkC,EAE7D0U,EAAwBC,OACxB/V,KAAK8X,aAAe,IAAIxW,EAAOD,CAAM,EACrCrB,KAAKic,SAAWI,EACXrc,KAAKic,UACNjc,KAAKgY,iBAEThY,KAAKwY,oBAskBT5Y,OAAOC,eAAeyB,EAAOxB,UAAW,SAAU,CAC9CC,IAAK,WACD,OAAOC,KAAKuH,YAAYvJ,OAAOwJ,YAEnCtH,WAAY,CAAA,EACZC,aAAc,CAAA,EACjB,EACDmB,EAAOxB,UAAUgI,KAAO,SAAU9J,EAAQ+d,EAAO3e,GAEzCU,EADO,IAAIC,WAAWiC,KAAKuH,YAAYvJ,OAAQgC,KAAKyB,SAAWsa,CAAK,EACxD9d,SAAS,EAAGb,CAAM,EAGlC,OAFAY,EAAOE,IAAIJ,EAAM,CAAC,EAClBkC,KAAKyB,UAAY3D,EAAK0J,WACf1J,EAAK0J,YAEhBlG,EAAOxB,UAAUkI,SAAW,WACxB,OAAOhI,KAAKuH,YAAYvH,KAAKyB,QAAQ,KAEzCH,EAAOxB,UAAU+E,MAAQ,SAAU6F,EAAavE,EAAQnH,GACpDhD,EAAMwB,UAAUkN,EAAa,EAAG1K,KAAKuH,YAAavH,KAAKyB,SAAW0E,EAAQnH,CAAK,EAG/EgB,KAAKyB,UAAYzC,GAErBsC,EAAOxB,UAAU0J,YAAc,WAC3B,OAAO,IAAIzL,WAAWiC,KAAKuH,YAAYvJ,MAAM,OA7BjDsD,EA+BOA,EA9BP,SAASA,EAAO9C,GACZwB,KAAKyB,SAAW,EAChBzB,KAAKuH,YAAc,IAAIxJ,WAAWS,EAAMR,MAAM"}